{"noir_version":"0.33.0+8ac81b15cd2a3b57493bfbfe444086deac8f3dc8","name":"Counter","functions":[{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_counter"]},{"name":"initialize","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","key_registry_get_stored_keys_hint","get_public_keys_and_partial_address","unsafe_rand","notify_created_note","get_key_validation_request","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"increment","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["debug_log_format","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","key_registry_get_stored_keys_hint","get_public_keys_and_partial_address","unsafe_rand","notify_created_note","get_key_validation_request","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Counter::increment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::increment_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Counter::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::initialize_parameters","fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"counters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}]}},"file_map":{"2":{"source":"use crate::cmp::Ord;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n","path":"std/array.nr"},"5":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiller can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"67":{"source":"contract Counter {\n\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n\n    //this seems to act like a map in solidity\n    #[aztec(storage)]\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n    }\n\n    #[aztec(private)]\n    #[aztec(initializer)]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n\n    #[aztec(private)]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        dep::aztec::oracle::debug_log::debug_log_format(\"Incrementing counter for owner {0}\", [owner.to_field()]);\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n        //get_balance operates on the owners counter, is this the owner of the contract or who is calling the function?\n        //yiedls a provate counter that only the owner can decrpyt. \n    }\n}\n\n//checking my understanding\n//the owner of the contract is the person who deployed it with the initaliser\n//      they can give themselves a headstart which is just more tokens on deployment\n//      i still dont understand the difference between owner and outgoing_viewer\n//      because it is private it is just someone who can view the counter, it cannot be anyone\n//      the why are they not present in the get_counter","path":"/Users/niallcheetham/dev/aztec/aztec-artifact-bug/counter/src/main.nr"},"72":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"73":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"75":{"source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"78":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"87":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"89":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"94":{"source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(_self: Self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        // 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        // the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        // implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        // 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime { EventSelector::from_signature(\"TestEvent(Field,Field,Field)\") }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr"},"95":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"96":{"source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"97":{"source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr"},"99":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"113":{"source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr"},"114":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"116":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"118":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"120":{"source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"124":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"125":{"source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"128":{"source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"129":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"136":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"141":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"146":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"147":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    point::Point, traits::Hash, hash::{sha256_to_field, poseidon2_hash_with_separator}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"149":{"source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr"},"151":{"source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"},"153":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"154":{"source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr"},"162":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"171":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"174":{"source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N, M> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N, M> + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N, M> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"212":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"254":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"266":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"286":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"287":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"289":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"293":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"294":{"source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"296":{"source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"297":{"source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"301":{"source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"302":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"303":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"306":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"317":{"source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n    keys::getters::get_current_public_keys\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_keys.npk_m.hash());\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_keys.npk_m.hash());\n        self.set.insert(&mut result_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr"},"319":{"source":"use dep::aztec::{\n    context::UnconstrainedContext, state_vars::PrivateSet,\n    note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions}\n};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote, UnconstrainedContext>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/value-note/src/balance_utils.nr"},"322":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH}\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.value);\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> ValueNoteHidingPoint {\n        ValueNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nstruct ValueNoteHidingPoint {\n  inner: Point\n}\n\nimpl ValueNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_value(&mut self, value: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(value.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for ValueNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.54.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}