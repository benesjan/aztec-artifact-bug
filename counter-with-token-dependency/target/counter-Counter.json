{"transpiled":true,"noir_version":"0.34.0+02fea6abe8637b9fb8f9535d1709b367d5e1da5c","name":"Counter","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":9,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"initialize","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7b3druPKlWb7LvvaFyRjMhhRr3Kw0XBVVzcMGHajyn2AA8PvfpS5kpQyRUpbJEXNj3PcNLy7SCUVY6y1OEfo55+//c///Pf/+7//x1/+9r/+/t+//dv/88/f/vr3//jzP/7y979d/uufv7X99/+///4/f/7bt//873/8+b/+8du/tUNnf/rtP//2P7/9z2T/+tNv/+svf/3P3/5taP71p7uDu9rmHwd3NZXp4JpmDk59HX4cnPK3h3t0cNsMKY3X0QyWp8O7PMwdn6YHb629Hv3tGdwf3DbTc2z7dHvw73/6rc2sy+y6DKzL7LoU3+syNNd1KfZsXUpux8NLaTatS2Vd5talazavSyptNz7VYtd1Ger3f6B99z/QbSfbNuM/0LWpmw5um3aWVnv94e5vjv6xouno6+n6Mj50Nww/Xc+cO+10IbW2V9P6PPvY16O7Wy/7uevOk8Vl6G+O7WZXsat5WsbU1ON+R3YGIeeEegj9IULp5j4j2XDg340MIeeEhjMRam8I1WeE2r5L1yc5PDv6g4wKjNwzqr4ZDTZeSNc0TxmlflqXvruuS2eDr1VPDav+gVVvP7nqpfw6S6U9ZrvpX+i61Dy5nq6v49J3Q1ueToKfI5VYmYWVse0r09n0XH+y8vJcv/0LO0wnqR9vIrt0cxe5sJp9uf7+qPmn3x/fric7u57B2fXscJeVyvRbzbr05Hpsct9yubua6ulqrHF1Na2rq9nhr0+yer0a+/U3ic3+Fh/y+AyGIT1+/NqN4tfhehfS9vM/JVNjrjfPtc4+bl/GhanZuie/vWs/rUjT3Bz8vc+aBXiO/cbnePmLNqW2y9/LJ88yDXnq4U8eOPfjofnmGtLlz/23y86alz1oXnbRvOz65LKLPbvs4fqjc/PX+dvjz00E1l4ngtu//Onb1fSNq6tpXV1N5+pq0rFXcxkyxqNTaX66mrk7/DLN7129vcOfnU7aUqcfvNsrmb8brX29VrP87LFLM03ApbspCd+Hmd5YxO2L2LOI2xcxs4h/aBG76W90SfXXRRxYxO2LWFjE7YtYWcQ/sohDno4u1vyyiLkJuojd9SVQ3U8vgVrxhyW3LOL2RexYxO2LGHVieXURH/1hycYibl/EqBPLrosYdWJ5cREf3+IEnljKdRHTT4/9bV0CDyEP1yXqXNE1049R1zZPH/vhjcgQd67YcRHjzhU7LmLcueK1RXx0IzLEnSt2XERjEbcvYty54qVFfHhLPATeCSnXRay/3voNjArz6xJ1VOjarp/WJW9rc0PYuWLHRSxh54o9FzHsXPHiIj66ESlh54o9FzHsXLHnIhqL+EcW8eEtcQn8CqvrrV++q6GFUWF+XVyPCun63k5L/bN1+dynZBTXg4XMKrqeLFRWsboeLWRW0fVsIbOKrocLmVV0PV3IrKKxijusouv5QmYVXU8jMqvI7LLHKjK77LGKzC47rGLbMLzssoxML7ss45nGl499DNTln2MZ91hGE13G7xd/9Nwwbam01jy7eJlPBWybzDLusYxHTw7T9xXcLeP3y9l8C95el7LN/bPLefxxIZcn5Opy2sbX5bS+LqfzdTnp2Ms55Sd8tK2xijusYs8q7rCKmVXc/CEfbTuwijusYmEVd1jFyipu/sSZtmuCruKeH/TRdi2ruMMqdqziDqsYdXbZ87M+2i7q7LLvKkadXfZdxaizy54fPNN2gWeXR5+w0naBx5HHCxN1wtjzEz/aFHfC2HMV404Ye65i3Aljvw/9aFPcCWPPVTRWcYdVjDth7PcJNG0KvDvy6KNW2sTQsLAwUYeGPT/6o01hJ4w9V9HCThi7rmLYCWPHT/9oLeyEsesqhp0wdl1FYxU3fxRNa4Fff/XoM1daY2hYWBjXQ4PM+5bM9Yihs4yuZwyZZexdDxk6y+h6ytBZRtdjhs4yup4zdJbRWMY9ltH1pKGzjK7nEp1lZIrZZRmZYnZZRqaYPZYxn2mK+dw77/OZppgPLqPqFPP94o+eHc75IRbbv9+XZfy2jEfPDo8/C2T7d+V2w3hs29X05HJKGg8uN6s+/wsv1THeW7ohWub416EdbanDTemf55mmTYTbR56l2Q3TJ690QylP0O/pyea7+s6aK5innxlT6mRVbW6Pzl+Xs/nuOF3vpaxtn11OtumnP9eb3+l9njl6qJNV7fUyLntFc8c245+W4aeryBuPtWYy0Jr+KkpXv9avsn6P1+/yi2Rcv3aov67f9m/Gje3f9i/FDe5fx/pt8i+xfpv8M9Zvk38967fJv8z6PTw2De04rqQh280E+rV+g+P1K9du2Vj9aQG/X7vne//ba799BeF47Z7vuy9z73R0U4cn5vZ9M06Xfd9ef8N9+2G9O7jrbPp9ePnfZreHf1uY4vmG+qMLs+udcrInC5PyMP3auHn1Yzd3rOU6jvSX/3n9QS2zfaGbPpOh7bpnL6yMHVtK55h5nu5rcnnCvPbDuCa1r83jn4Ra0oSxDPc/B4k1uVsTY03u1qRnTe7WJAdck8t2eZret9Z0Jd+tysCqzKxKCbkqOTXX+/abvaDZw4PfnVQMuRntfvzc1IZVmVkVz9PL51Yl4v39ZdCbnmDblObuL0+NeIf/fFWMVZlZlYh3+c9XJeZ9/rNViXmf/2xVYt7nP1uVmPe2j1ela2Le2z5blZj3ts9WhXvbuVXh3nZuVYxVmVkV7m3nVoV727lV4d52blW4t51bFe5tZ1al5d52blW4t51bFe5t51aFe9u5VTFWZWZVuLedWxXubedWhXvbuVXh3nZuVbi3nVmVjnvbuVXh3nZuVbi3nVsV7m3nVsVYlZlV4d52blW4t51bFe5t51aFe9u5VeHedmZVEve2c6vCve3cqnBvO7cq3NvOrYqxKjOrwr3t3Kpwbzu3Ktzbzq0K97Zzq8K97cyqGPe2c6vCve3cqnBvO7cq3NvOrYqxKjOrwr3t3Kpwbzu3Ktzbzq0K97Zzq8K97cyq9Nzbzq0K97Zzq8K97dyqcG87tyrGqsysCve2c6vCve3cqnBvO7cq3NvOrQr3tjOrkrm3nVsV7m3nVoV727lV4d52blWMVZlZFe5t51aFe9u5VeHedm5VuLedWxXubWdWZXB8b1unDzfum759vCrfvkV7ep65eXxw6m380orU33yLU5pfwelLQtqmv33g7+vn+C5YYv0c3y9LrJ/jO+uX1q8r0/fIWH7yK7Cr0xf8dpd/5Hrw3K/Avpu+t6tPtwv44xegsYDPFnDI1wXMjw9+/AV53eD45l5xtR9+nV43OB4anKz29fvf+9Q3T1bb+ukLIuzmzqub/R3/8Jv6usHx5HJ6NMXGy0hlBo3j8Sk6GsczXHA05SyD5AnRnGVGPSGas4y/J0TDZO0WjYHGKxoGfLdoItaA1AzTmtx+x/f8ateJjN2A6ecoTl803t9872Lb5NdTgOcvLD03lyc/LxE7gAKXiBFAgIvnr0oNzSXi+K/AJeLsr8Al4uCvwMXg4pJLxJFfgQvz/n5ccjMuRU79Ey4lj8eWcn1ubUlfWBj3P4OlZvtxbL390Spzr7pL1caX811W+/rI3dwDW7q+fDd9e7jrwd+B0xGCASdQhAKePH+RNsDfAZykEgw4rSYYcCJQMOAG8FjAyVbBgNPDggGntAUDTmkLBpzSFgt4S2kLBpzSFgw4pS0YcEpbMOAG8FjAKW3BgFPaggGntAUDTmkLBpzSFgt4R2kLBpzSFgw4pS0YcEpbMOAG8FjAKW3BgFPaggGntAUDTmkLBpzSFgt4orQFA05pCwac0hYMOKUtGHADeCzglLZgwCltwYBT2oIBp7QFA05piwXcKG3BgFPaggGntAUDTmkLBtwAHgs4pS0YcEpbMOCUts8AvyxWO11wn58g7y2n6SpKfoz8Qnxa5Xzrx9w1XzhNX5CZWrs9+LsfhDn8eOQHHQ8/HvjRk/3w45EfVMLgflyv49IXhjs/iIr48cgPGmR0P6Zv/LsMK+3jg7s6jI/c1VKfHGw2zuSd5eHxwdfnZ7eP+zVk94akSOpdUlovkr5L0jI+ctc3dYuk9GkkdS8pTR1J3yTp0I0r1w3ZnhzcpGY8uOnTFqPZBcDocxnNvgVGuzA6l8no2m4wOrPTgtHnMpq9IYz+w0anpk3TwnVPHrlLw2R0qt3twd/NY9cJ895k3m7BNrP1haTuJTUkRVLvkrL1haTvknSvXYXM1heSupeUrS8kfZOkfZ3+3OeuuRvZ2aLCvM+Yx1YS5n3EvIEtH8z7jHlszWDem8x7ZbOxLWVajtrc7eMM7OOgqYCm7OSgqQNN93t53WAYjdGnMpo9Iow+l9FsKGG0C6P3esHowO4TRp/LaHa1MPoFo+v0WSltt7FJsKuFeR8xr7CrhXnvMW+/4amwAYak7iVl+wtJ3UvK5heSvkvSvebwYkiKpN4lZYsquKS9TWvR90/eEffaJ0A8fr98YSsJ895k3m7v8izsDiGpe0nZ8EFS95KyN4Sk75J0r7ciV7aRkNS9pGwjIembJH38Dr7K3hDmfcY8Nnww7zPmGeZh3kfMY2sG895k3o5vRK7s46CpgKbs5KCpA033exFcZdsHo89lNHtEGH0mo61hQwmjXRi90wtGrWH3CaPPZTS7Whj9h43+zNeNWMMGGJK6l9SQFEnfJOlOL5+yhm01JHUvKZtqSPomST9Uwth/w+hzGc3+G0a7MHq3Esb+G0afyuiW/TeMfsHo3T6R0lr2yTDvM+axn4V57zFvv+GpZT8LSd1LakiKpN4lZT8LSd8l6W5zOPtZSOpeUraoPiRpacbHbUvX/iTpdzDstDgFw4aBTzAd3dspGLKwAzCt3YOhmjoFQyl0CsYA4xMMRcgpGCqIUzBM/k5vl5n8nYJh8vcJJjH5OwXD5O8UDJO/UzBM/k7BGGB8gmHydwqGyd8pGCZ/p2CY/P29Yug7GCZ/n2CMyd8pGCZ/p2CY/J2CYfLfD8wwvfK2tM0TMLmpI8Sb192mHy+QNQOLRyxM/S6xMPO7xMLE7xIL875LLEz7HrH0zPousTDpu8TCnO8SC1O+SywGFo9YmPJdYmHKd4mFKd8lFqZ8l1iY8j1iyUz5LrEw5bvEwpTvEgtTvkssBhaPWJjyXWJhyneJhSnfJRamfJdYmPI9YhmY8l1iYcp3iYUp3yUWpnyXWAwsHrEw5bvEwpTvEgtTvkssTPkusTDle8RSmPJdYmHKd4mFKd8lFqZ8l1gMLB6xMOW7xMKU7xILU75LLEz5LrEw5XvEUpnyXWJhyneJhSnfJRamfJdYDCwesTDlu8TClO8SC1O+SyxM+S6xMOU7xNI3TPkusTDl74el1PEa6tOPc+/y+LBdTddVm3vYvhkXrU/d40NTsfESUvn5cb/TJh5Eok2TiETboB2INgUlEm3CTCTa9J5ItMlIkWhTpwLRbolekWjT0iLRpqVFok1Li0TboB2INi0tEm1aWiTatLRItGlpkWjT0gLR7mhpkWjT0iLRpqVFok1Li0TboB2INi0tEm1aWiTatLRItGlpkWjT0gLRTrS0SLRpaZFo09Ii0aalRaJt0A5Em5YWiTYtLRJtWlok2rS0SLRpaYFoGy0tEm1aWiTatLRItGlpkWgbtAPRpqVFok1Li0SblhaJNi0tEm1aWiDaPS0tEm1aWiTatLRItGlpkWgbtAPRpqVFok1Li0SblhaJNi0tEm1aWiDamZYWiTYtLRJtWlok2rS0SLQN2oFo09Ii0aalnYm2Nbn+ONbaLj8+uK39uAxtLfdqEN5QY0ENKh1qLKhB0kONeTUG+h9qLKhBLESNBTUoi6ixoAYZEjUW1DDUQI15NQicqLGgBjUUNRbUoIaixoIa1FDUWFCDGooa82oUaihqLKhBDUWNBTWooaixoAY1FDUW1DDUQI15NaihqLGgBjUUNRbUoIaixoIa1FDUWFCDGooa82pUaihqLKhBDUWNBTWooaixoAY1FDUW1DDUQI15NaihqLGgBjUUNRbUoIaixoIa1FDUWFCDGnomNfqmjs+sb1PzC+3cEDgj0aZZRqJNhoxEm7IYibZBOxBt+l8k2iS9SLSpdJFoE94i0aalBaLd0tIi0aalRaJNS4tEm5YWibZBOxBtWlok2rS0SLRpaZFo09Ii0aalBaLd0dIi0aalRaJNS4tEm5YWibZBOxBtWlok2rS0SLRpaZFo09Ii0aalBaKdaGmRaNPSItGmpUWiTUuLRNugHYg2LS0SbVpaJNq0tEi0aWmRaNPSAtE2Wlok2rS0SLRpaZFo09Ii0TZoB6JNS4tEm5YWiTYtLRJtWlok2rS0QLR7Wlok2rS0SLRpaZFo09Ii0TZoB6JNS4tEm5YWiTYtLRJtWlok2rS0QLQzLS0SbVpaJNq0tEi0aWmnop2mr2bvL2DuaBu0A9GmpUWiTUuLRJuWFok2LS0SbVpaINoDLS0SbVpaJNq0tEi0aWmRaBu0A9GmpUWiTUuLRJuWFok2LS0SbVpaINqFlhaJNi0tEm1aWiTatLRItA3agWjT0iLRpqVFok1Li0SblhaJNi0tEO1KS4tEm5YWiTYtLRJtWlok2gbtQLRpaZFo09Ii0aalRaJNS4tEm5YWh/bQ0NIi0aalRaJNS4tEm5YWibZBOxBtWlok2rS0SLRpaZFo09Ii0aalBaLd0tIi0aalRaJNS4tEm5YWibZBOxBtWlok2rS0SLRpaZFo09Ii0aalBaLd0dIi0aalRaJNS4tEm5YWibZBOxBtWlok2rS0SLRpaWeinZvU/Dg2N7W7o01Li0SblhaIdqKlRaJNS4tEm5YWiTYtLRJtg3Yg2rS0SLRpaZFo09Ii0aalRaJNSwtE22hpkWjT0iLRpqVFok1Li0TboB2INi0tEm1aWiTatLRItGlpkWjT0gLR7mlpkWjT0iLRpqVFok1Li0TboB2INi0tEm1aWiTatLRItGlpkWjT0gLRzrS0SLRpaZFo09Ii0aalRaJt0A5Em5YWiTYtLRJtWlok2rS0U9FOzUgjp5TuaNPSAtEeaGmRaNPSItGmpUWiTUuLRNugHYg2LS0SbVpaJNq0tEi0aWmRaNPSAtEutLRItGlpkWjT0iLRpqVFom3QDkSblhaJNi0tEm1aWiTatLRItGlpgWhXWlok2rS0SLRpaZFo09Ii0TZoB6JNS4tEm5YWiTYtLRJtWlok2rS0OLRLQ0uLRJuWFok2LS0SbVpaJNoG7UC0aWmRaNPSItGmpUWiTUuLRJuWFoh2S0uLRJuWFok2LS0SbVpaJNoG7UC0aWmRaNPSItGmpUWiTUuLRJuWFoh2R0uLRJuWFok2LS0SbVpaJNoG7TPRztlG2rn2d7RpaZFo09Ii0aalnYr20NSR9pDq44Mvv9hHNS4elCcHT0qUnw/9bhGNDou2W0T7w6LNFiWaIhZtt4hWiUXbLaKBYtF2i2irWLTdIsMiLNpsES0Yi7ZbRGPGou0W0a6xaLtFtGss2m4R7RqLNltktGss2m4R7RqLtltEu8ai7RbRrrFou0WGRVi02SLaNRZtt4h2jUXbLaJdY9F2i2jXWLTdIto1Fm22qKddY9F2i2jXWLTdIto1Fm23iHaNRdstMizCos0W0a6xaLtFtGss2m4R7RqLtltEu8ai7RbRrrFos0WZdo1F2y2iXWPRdoto11i03SLaNRZtt8iwCIs2W0S7xqLtFtGusWi7RbRrLNpuEe0ai7ZbRLvGos0WDbRrLNpuEe0ai7ZbRLvGou0W0a6xaLtFhkVYtNki2jUWbbeIdo1F2y2iXWPRdoto11i03SLaNRZttqjQrrFou0W0ayzabhHtGou2W0S7xqLtFhkWYdFmi2jXWLTdIto1Fm23iHaNRdstol1j0XaLaNdYtNmiSrvGou0W0a6xaLtFtGss2m4R7RqLtltkWIRFmy2iXWPRdoto11i03SLaNRZtt4h2jUXbLaJdY9FWi2pDu8ai7RbRrrFou0W0ayzabhHtGou2W2RYhEWbLaJdY9F2i2jXWLTdIto1Fm23iHaNRdstol1j0WaLWto1Fm23iHaNRdstol1j0XaLaNdYtN0iwyIs2mwR7RqLtltEu8ai7RbRrrFou0W0ayzabhHtGos2W9TRrrFou0W0ayzabhHtGou2W0S7xqLtFhkWYdFmi2jXWLTdIto1Fm23iHaNRdstol1j0XaLaNdYtNmiRLvGou0W0a6xaLtFtGss2m4R7RqLtltkWIRFmy2iXWPRdoto14EtSv1kUcl3ahCkUWNBDSozaiyoQTpGjXk1jB6MGgtqEHlRY0ENyi1qLKhBjkWNBTUMNVBjXg3CKWosqEENjatGGsaDi7X2+ODLmqVpzcr1kbu5J2dtPz47a4d0e/B36eisSHe4dBRcpDtcOtow0h0tXU91RrrDpaNnI93h0lHKke5w6WjwSHe4dIZ0SHe0dOwbIN3h0rEjgXSHS8eOBNIdLh07Ekh3uHTsSCDd0dJldiSQ7nDp2JFAusOlY0cC6Q6Xjh0JpDtcOkM6pDtaOnYkkO5w6diRQLrDpWNHAukOl44dCaQ7XDp2JJDuaOkGdiSQ7nDp2JFAusOlY0cC6Q6Xjh0JpDtcOkM6pDtaOnYkkO5w6diRQLrDpWNHAukOl44dCaQ7XDp2JJDuaOkKOxJId7h07Egg3eHSsSOBdIdLx44E0h0unSEd0h0tHTsSSHe4dOxIIN3h0rEjgXSHS8eOBNIdLh07Ekh3tHSVHQmkO1w6diSQ7nDp2JFAusOlY0cC6Q6XzpAO6Y6Wjh0JpDtcOnYkkO5w6diRQLrDpWNHAukOl44dCaQ7WLq2adiSwLrjrWNPAuuOt45NiSfWDX0zrUX/2LpUbcR4WZX+CZk0eWepzJCh3HslY5BxSoYG7JUModQrGWqiVzIkN69k6FJOybS0G69k6BteydAAvJKhAXglY5BxSoYG4JUMDcArGRqAVzI0AK9kaABOyXQ0AK9kaABeydAAvJKhAXglY5BxSoYG4JUMDcArGRqAVzI0AK9kaABOySQagFcyNACvZGgAXsnQALySMcg4JUMD8EqGBuCVDA3AKxkagFcyNACnZIwG4JUMDcArGRqAVzI0AK9kDDJOydAAvJKhAXglQwPwSoYG4JUMDcApmZ4G4JUMDeAZmTpeckntLZmv9Qs5qbd5tDW1t7pu/LzI3qZDy/XQ+c+LTENbpqXI13Xr7AeYkIO6BzDFph+uMgfGAOMTTMgxXQFMyCldAUzIIV0BTMgZXQFMyBFdAEwOOaErgAk5oCuAYfLfD0xuxqXIT78pouTx2FKuz629xK0vLgz+n+FSs/04tt7+cH2Ljv98a8PMBvFgxEkV0YjTQKIRJ65EI061iUacHBSM+EBnikacgBWNOGUsGnGaWzTiBvFgxGlu0YjT3KIRp7lFI05zi0ac5haMeKG5RSNOc4tGnOYWjTjNLRpxg3gw4jS3aMRpbtGI09yiEae5RSNOcwtGvNLcohGnuUUjTnOLRpzmFo24QTwYcZpbNOI0t2jEaW7RiNPcohGnucUi3jY0t2jEaW7RiNPcohGnuUUjbhAPRpzmFo04zS0acZpbNOI0t2jEaW7BiLc0t2jEaW7RiNPcohGnuX2G+GWx2umC+/yEeW85TVdR8mPmF+TTKudbQeau+cJp+nbN1NrtwV+CGIIgyCNBKHoI8lAQAiCCPBSEXhhckOt1JLPhXhDyIoI8FIQaGV2Q6asCk918V+DswV0dxkfuaqlPDjYbR/PO8vD44Ovzs9vH/TFrdxRULPVvKdUXS99laRkfueubuslSSjWW+reUuo6lb7J06MaV64ZsTw5u0oika/q0SWlDaZQ+l9LsYKC0C6VzmZSu7Sal2XNB6ZMpzS4RSv9hpVPTjpeRmu7JI3dpmJROtbs9+Es99p9Q703q7Rhu2QTDUveWJjbBsNS/pWyCYem7LN1teyGxCYal/i1lEwxL32RpX6e/+Llr7gb3ZKiHep9Rj00l1PuQemz+oN6H1GOTBvXepN4r+45tKdNy1OZ+Ryexo4OnCp6yp4OnDjzd8dV2xgYQSp9MaXaLUPpkSrO1hNIulN7tBaTGPhRKn0xpQ2mU/uNK1+lTVNpuY5kw9rdQ70Pqsb+Feu9Rb88Jiq0wLPVvKRthWOrfUrbBsPRdlu42jffsbGGpf0vZrApuaW8j69T3T94m99pHQzx5H33PphLqvUm9/d772bNPhKX+LTUsxVL3lrJLhKXvsnS3dyj3bChhqX9L2VDC0jdZ+uRtfT27RKj3IfXY+kG9z6iX2c9BvQ+pxyYN6r1JvT3fn5zZ0cFTBU/Z08FTB57u+Jq4bCiN0udSmt0ilD6Z0mwtobQLpXd7AWlmHwqlT6Y0+1so/YeV/tSXkmS2wrDUvaUDu2ZY+i5Ld3sx1cAGG5b6t5TtNSx9k6UfCmIDO3EofTKlDaVR2oPSuwWxgZ04lD6Z0uzEofQLSu/4gZUDO2ao9yH12NlCvfeot+cExc4Wlrq3tLCzhaX+LWVnC0vfZelu03hhZwtL/VvKZtWHLC3N+LiXXxXtT5Z+kTHIOCXD1oFXMhRwr2QIxA7ItDZDhn7qlQzN0CmZSifzSoY25JUMPcTpvVmlAXglY5BxSoYG4JUMDcArGRqAVzI0AK9kaAA+yXQNDcArGRqAVzI0AK9kaAD+Xq3yRcYg45QMDcArGRqAVzI0AK9kaAD7kRmml36WtnlCJjd1pHjzws/04xWaXUMBcMmlZf73yYXp3ycXZn+fXJj8fXIxuLjkwtTvkwszv08uTPw+uTDv++TCvO+SS8e875ML875PLsz7Prkw7/vkYnBxyYV53ycX5n2fXJj3fXJh3vfJhXnfJZfEvO+TC/O+Ty7M+z65MO/75GJwccmFed8nF+Z9n1yY931yYd73yYV5fz8upY7XUJ++A6bL07ey1ev3D6S5h+2bcdH61D0+NBWbvhmu/Py433EbGSEUbupEKNxEj1C4aSmhcBu4I+Gm/ITCTVAKhZtOFQo3+SsUbqpaJNw9VS0UbqpaKNxUtVC4qWqhcBu4I+GmqoXCTVULhZuqFgo3VS0UbqpaJNyZqhYKN1UtFG6qWijcVLVQuA3ckXBT1ULhpqqFwk1VC4WbqhYKN1UtEu6BqhYKN1UtFG6qWijcVLVQuA3ckXBT1ULhpqqFwk1VC4WbqhYKN1UtEu5CVQuFm6oWCjdVLRRuqloo3AbuSLipaqFwU9VC4aaqhcJNVQuFm6oWCXelqoXCTVULhZuqFgo3VS0UbgN3JNxUtVC4qWqhcFPVQuGmqoXCTVULhDs1VLVQuKlqoXBT1ULhpqqFwm3gPhFua3L9cay1XX58cFv7EXNby4wbJDjcWHKDXocbS24Q93BjyQ1KIG4suUE2xI0FN1oaI24suUGQxI0lN6iXuLHkBqkTN5bcMNzAjQU36KK4seQGXRQ3ltygi+LGkht0UdxYcoMuihsLbnR0UdxYcoMuihtLbtBFcWPJDboobiy5YbiBGwtu0EVxY8kNuihuLLlBF8WNJTfoorix5AZdFDcW3Eh0UdxYcoMuihtLbtBFcWPJDboobiy5YbiBGwtu0EVxY8kNuihuLLlBFz2TG31TR3J9m5p73KTOULipl5FwG0EyFG4aYyjcZMNQuCmBoXAbuCPhpteFwk2CC4WbqhYKN1UtFG6qWiTcPVUtFG6qWijcVLVQuKlqoXAbuCPhpqqFwk1VC4WbqhYKN1UtFG6qWiTcmaoWCjdVLRRuqloo3FS1ULgN3JFwU9VC4aaqhcJNVQuFm6oWCjdVLRLugaoWCjdVLRRuqloo3FS1ULgN3JFwU9VC4aaqhcJNVQuFm6oWCjdVLRLuQlULhZuqFgo3VS0UbqpaKNwG7ki4qWqhcFPVQuGmqoXCTVULhZuqFgl3paqFwk1VC4WbqhYKN1UtFG4DdyTcVLVQuKlqoXBT1ULhpqqFwk1VC4TbGqpaKNxUtVPhTtN3u/cXMPe4qWqhcFPVQuE2cEfCTVULhZuqFgo3VS0UbqpaKNxUtUi4W6paKNxUtVC4qWqhcFPVQuE2cEfCTVULhZuqFgo3VS0UbqpaKNxUtUi4O6paKNxUtVC4qWqhcFPVQuE2cEfCTVULhZuqFgo3VS0UbqpaKNxUtUi4E1UtFG6qWijcVLVQuKlqoXAbuCPhpqqFwk1VC4WbqhYKN1UtFG6qWiTcRlULhZuqFgo3VS0UbqpaKNwG7ki4qWqhcFPVQuGmqoXCTVULhZuqFgl3T1ULhZuqFgo3VS0UbqpaKNwG7ki4qWqhcFPVQuGmqoXCTVULhZuqFgl3pqqFwk1VC4WbqhYKN1UtFG4DdyTcVLUz4c5NGp9Zbmp3j5uqFgo3VS0UbqpaKNxUtUi4B6paKNxUtVC4qWqhcFPVQuE2cEfCTVULhZuqFgo3VS0UbqpaKNxUtUi4C1UtFG6qWijcVLVQuKlqoXAbuCPhpqqFwk1VC4WbqhYKN1UtFG6qWiTclaoWCjdVLRRuqloo3FS1ULgN3JFwU9VC4aaqhcJNVQuFm6oWCjdVLRDuvqGqhcJNVQuFm6oWCjdVLRRuA3ck3FS1ULipaqfCnZqRRk4p3eOmqoXCTVULhZuqFgl3S1ULhZuqFgo3VS0UbqpaKNwG7ki4qWqhcFPVQuGmqoXCTVULhZuqFgl3R1ULhZuqFgo3VS0UbqpaKNwG7ki4qWqhcFPVQuGmqoXCTVULhZuqFgl3oqqFwk1VC4WbqhYKN1UtFG4DdyTcVLVQuKlqoXBT1ULhpqqFwk1Vi4TbqGqhcFPVQuGmqoXCTVULhdvAHQk3VS0UbqpaKNxUtVC4qWqhcFPVIuHuqWqhcFPVQuGmqoXCTVULhdvAHQk3VS0UbqpaKNxUtVC4qWqhcFPVIuHOVLVQuKlqoXBT1U6FO2cbcefa3+OmqoXCbeCOhJuqdircQ1NH3EOqjw8uXT+6UbobHPMHT0qUnw/90ohah0Y7aEQFRKMdNKIuotEOGlEt0Wi7RgM1FI120IjKikY7aES9RaMdNKIKo9EOGhkaodF2jajYaLSDRlRsNNpBIyo2Gu2gERUbjXbQiIqNRts1KlRsNNpBIyo2Gu2gERUbjXbQiIqNRjtoZGiERts1omKj0Q4aUbHRaAeNqNhotINGVGw02kEjKjYabdeoUrHRaAeNqNhotINGVGw02kEjKjYa7aCRoREabdeIio1GO2hExUajHTSiYqPRDhpRsdFoB42o2Gi0WaPcULHRaAeNqNhotINGVGw02kEjKjYa7aCRoREabdeIio1GO2hExUajHTSiYqPRDhpRsdFoB42o2Gi0XaOWio1GO2hExUajHTSiYqPRDhpRsdFoB40MjdBou0ZUbDTaQSMqNhrtoBEVG4120IiKjUY7aETFRqPtGnVUbDTaQSMqNhrtoBEVG4120IiKjUY7aGRohEbbNaJio9EOGlGx0WgHjajYaLSDRlRsNNpBIyo2Gm3XKFGx0WgHjajYaLSDRlRsNNpBIyo2Gu2gkaERGm3XiIqNRjtoRMVGox00omKj0Q4aUbHRaAeNqNhotF0jo2Kj0Q4aUbHRaAeNqNhotINGVGw02kEjQyM02q4RFRuNdtCIio1GO2hExUajHTSiYqPRDhpRsdFou0Y9FRuNdtCIio1GO2hExUajHTSiYqPRDhoZGqHRdo2o2Gi0g0ZUbDTaQSMqNhrtoBEVG4120IiKjUbbNcpUbDTaQSMqNhrtoBEVG4120IiKjUY7aGRohEbbNaJio9EOGlGx0WgHjajYaLSDRlRsNNpBIyo2Gm3XaKBio9EOGlGx0WgHjajYaLSDRlRsNNpBI0OjuBqlftKo5Hs3SNNx3UjDeHCx1h4fnJphfHKpKddH7uaenLX9+OysHdLtwV/WUbKx7njrCN9Yd7x1dHKsO946sjrWHW5docJj3fHWEe2x7njraPxYd7x1bAlg3fHWGdZh3eHWsTeBdcdbx94E1h1vHXsTWHe8dexNYN3x1rE3gXWHW1fZm8C6461jbwLrjreOvQmsO9469iaw7njrDOuw7nDr2JvAuuOtY28C6463jr0JrDveOvYmsO5469ibwLqjrRsa9iaw7njr2JvAuuOtY28C6463jr0JrDveOsM6rDvcOvYmsO5469ibwLrjrWNvAuuOt469Caw73jr2JrDucOta9iaw7njr2JvAuuOtY28C6463jr0JrDveOsM6rDvcOvYmsO5469ibwLrjrWNvAuuOt469Caw73jr2JrDucOs69iaw7njr2JvAuuOtY28C6463jr0JrDveOsM6rDvcOvYmsO5469ibwLrjrWNvAuuOt469Caw73jr2JrDucOsSexNYd7x17E08sW7om2kt+sfWpWojxsuq9E/IpMk7S2WGDP3eKxkat1cyBhmnZGilXsnQE72Sobl5JUOX8kqGduOUjNE3vJKhAXglQwPwSoYG4JWMQcYpGRqAVzI0AK9kaABeydAAvJKhATgl09MAvJKhAXglQwPwSoYG4JWMQcYpGRqAVzI0AK9kaABeydAAvJKhATglk2kAXsnQALySoQF4JUMD8ErGIOOUDA3AKxkagFcyNACvZGgAXsnQAJySGWgAXsnQALySoQF4JUMD8ErGIOOUDA3AKxkagFcyNACvZGgAXsnQAJySKTSAZ2TqeMkltbdkvtYv5KTepfGaU1fbx+vXt9PnRd6u35ysw/TBjkPb3qxEfvtPQcip/nQUQxaA01E0KJ6AYsiycDqKISvE6SiGLBanoxiybpyOYsgScjaKNWQ1OR1F2s0ZKNJuzkCRdnMGigbFE1Ck3ZyBIu3mDBRpN2egSLs5A0XajT7F0tBuzkCRdnMGirSbM1Ck3ZyBokHxBBRpN2egSLs5A0XazRko0m7OQJF2cwKKLe3mDBRpN2egSLs5A0XazRkoGhRPQJF2cwaKtJszUKTdnIEi7eYMFGk3J6DY0W7OQJF2cwaKtJszUKTdnIGiQfEEFGk3Z6BIuzkDRdrNGSjSbs5AkXZzAoqJdnMGirSbM1Ck3ZyBIu3mDBQNiiegSLs5A0XazRko0m7OQJF2cwaKtJsTUDTazRko0m7OQJF2cwaKtJszUDQonoAi7eYMFGk3Z6BIuzkDRdrNGSjSbk5AsafdnIEi7eYMFGk3Z6BIuzkDRYPiCSjSbs5AkXZzBoq0mzNQpN2cgSLt5gQUM+3mDBRpN2egSLs5A0XazRkoGhRPQJF2cwaKtJszUKTdnIEi7eYMFGk3J6A40G7OQJF2cwaKtJszUKTdnIGiQfEEFGk3Z6BIuzkDRdrNGSjSbs5AkXZzAoqFdnMGirSbM1Ck3ZyBIu3mDBQNiiegSLs5A0XazRko0m7OQJF2cwaKtJsTUKy0mzNQpN2cgSLt5gwUaTdnoGhQPAFF2s0ZKNJuzkCRdnMGirSbM1Ck3ehTrA3t5gwUaTdnoEi7OQNF2s0ZKBoUT0CRdnMGirSbM1Ck3ZyBIu3mDBRpNyeg2NJuzkCRdnMGirSbM1Ck3ZyBokHxBBRpN2egSLs5A0XazRko0m7OQJF2cwKKHe3mDBRpN2egSLs5A0XazRkoGhRPQJF2cwaKtJszUKTdnIEi7eYMFGk3J6CYaDdnoEi7OQNF2s0ZKNJuzkDRoHgCirSbM1Ck3ZyBIu3mDBRpN2egSLs5AUWj3ZyBIu3mDBRpN2egSLs5A0WD4gko0m7OQJF2cwaKtJszUKTdnIEi7eYEFHvazRko0m7OQJF2cwaKtJszUDQonoAi7eYMFGk3Z6BIuzkDRdrNGSjSbk5AMdNuzkCRdnMGirSbM1Ck3ZyBokHxBBRpN2egSLs5A0XazRko0m7OQJF2cwKKA+3mDBRpN2egSLs5A0XazRkoGhRPQJF2cwaKtJszUIzeblLbPKZY2/Eqal8eU+xtAl6uj9o2sxSHtkxLka/r1tkPMNFzzMfAFBvXOJU5MNELi1cwJXo0cQsmegdxCyZ62nALJnqtcAvGAOMTTPSm4BZM9EzgFgyT/35gcjM+bE79EzAlj8eWcn1u7SXOfHFh8P8Ml5ptfNjbH65v0eyfb21whaIQjHglVUQjTgOJRpy4Eo041SYacYN4MOJ0pmjECVjRiFPGohGnuUUjTnMLRbxrGppbNOI0t2jEaW7RiNPcohE3iAcjTnOLRpzmFo04zS0acZpbNOI0t2DEW5pbNOI0t2jEaW7RiNPcohE3iAcjTnOLRpzmFo04zS0acZpbNOI0t2DEO5pbNOI0t2jEaW7RiNPcohE3iAcjTnOLRpzmFo04zS0acZpbNOI0t2DEE80tGnGaWzTiNLdoxGlu0YgbxIMRp7lFI05zi0ac5haNOM3tM8Qvi9VOF9znJ8x7y+PT663kx8wvyKdVzreC9HMHp6Zc18JuD/4ShESHII8EMYoegjwUhACIIA8FoRcGF+R6HclsuBeEvIggDwUxBAkuyPRVgcluvitw9uCuDuMjd7XUJwebjaN5Z3l4fPD1+dnt4/6YtY2CiqX+LaX6Yum7LC3jI3d9UzdZSqnGUv+WUtex9E2WDt24sdMN2Z4c3KRmPLjp0yal2Q9A6XMp3bODgdIulM5lUrq2m5RmzwWlT6Y0u0Qo/YeVTk07XkZquieP3KVhUjrV7vbgL/XYf0K9N6m3X7jtDUux1L2lbIJhqX9L2QTD0ndZutv2Qs8mGJb6t5RNMCx9k6V9nf7i5665H9zZrEK9z6iX2VRCvQ+px+YP6n1IPTZpUO9N6r2y79iWMi1Hbe53dDI7Oniq4KnhKZ5+3tMdX22X2QBC6ZMpzW4RSp9MabaWUNqF0ru9gDSzD4XSJ1Oa/S2UfkHpOn2KStttLBMD+1uo9yH12N9Cvfeot+MENbAVhqX+LWUjDEv9W2pYiqVvsnS3aXxgZwtL/VvKZlVwS3sbWae+f/I2udc+GuLJ++gHNpVQ703q7ffez4F9Iiz1bylbP1jq3tLCLhGWvsvS3d6hXNhQwlL/lrKhhKVvsvTJ2/oKu0So9yH1DPVQ7zPqsZ+Deh9Sj00a1HuTenu+P7mwo4OnCp6yp4OnDjzd8TVxhQ0glD6X0pXdIpQ+mdJsLaG0C6V3ewFpZR8KpU+mNPtbKP2Hlf7Ul5JUw1IsdW8pu2ZY+i5Ld3sxVWWDDUv9W8r2Gpa+ydJPBTF24lD6ZEqzE4fSLpTeK4i1DTtxKH0ypdmJQ+kXlN7vAyvbhh0z1PuQeuxsod571Ntvgmobw1IsdW8pO1tY6t9Sdraw9F2W7jeNs7OFpf4tZbPqQ5aWZoyEbenanyz9IsOei1MyLVsHXslQwL2SIRA7INPaDBn6qVcyBhmnZOhkXsnQhrySoYd4vTejAXglQwNwSqajAXglQwPwSoYG4JUMDcArGYOMUzI0AK9kaABeydAAvJKhAfh7tcoXGRqAUzKJBuCVDA3AKxkagFcyNID9yAzTSz/LzaPOk8lNHSnevPAzja/QTAYXl1yY/31yYfr3yYXZ3ycXJn+fXJj7XXIxpn6fXJj5fXJh4vfJhXnfJxeDi0suzPs+uTDv++TCvO+TC/O+Ty7M+y659Mz7Prkw7/vkwrzvkwvzvk8uBheXXJj3fXJh3vfJhXnfJxfmfZ9cmPddcsnM+z65MO/75MK875ML875PLgaX3biUOl5DffoOmC5P38pWr98/kOY+M7tvxkXrU/f40FRs+ma48vPjfuEmI4TCTZ0IhZvoEQo3LSUUbhJNJNwD5ScUboJSKNx0qlC4yV+hcBu4I+GmqoXCTVULhZuqFgo3VS0UbqpaJNyFqhYKN1UtFG6qWijcVLVQuA3ckXBT1ULhpqqFwk1VC4WbqhYKN1UtEu5KVQuFm6oWCjdVLRRuqloo3AbuSLipaqFwU9VC4aaqhcJNVQuFm6oWCHfXUNVC4aaqhcJNVQuFm6oWCreBOxJuqloo3FS1ULipaqFwU9VC4aaqRcLdUtVC4aaqhcJNVQuFm6oWCreBOxJuqloo3FS1ULipaqFwU9VC4aaqRcLdUdVC4aaqhcJNVQuFm6oWCreBOxJuqloo3FS1ULipaqFwU9VC4aaqnQm3Nbn+ONbaLj8+uK39iLmt5d6NRILDjSU36HW4seQGcQ83ltygBOLGkhuGG7ix4AaNETeW3CBI4saSG9RL3Fhyg9SJG0tu0EVxY8ENo4vixpIbdFHcWHKDLoobS27QRXFjyQ3DDdxYcIMuihtLbtBFcWPJDboobiy5QRfFjSU36KK4seBGTxfFjSU36KK4seQGXRQ3ltygi+LGkhuGG7ix4AZdFDeW3KCL4saSG3RR3Fhygy6KG0tu0EVxY8GNTBfFjSU36KK4seQGXfRMbvRNHcn1bWrucZM6Q+E2cEfCTZAMhZvGGAo32TAUbkpgKNzEvUi4B3pdKNwkuFC4qWqhcFPVQuE2cEfCTVULhZuqFgo3VS0UbqpaKNxUtUi4C1UtFG6qWijcVLVQuKlqoXAbuCPhpqqFwk1VC4WbqhYKN1UtFG6qWiTclaoWCjdVLRRuqloo3FS1ULgN3JFwU9VC4aaqhcJNVQuFm6oWCjdVLRDu1FDVQuGmqoXCTVULhZuqFgq3gTsSbqpaKNxUtVC4qWqhcFPVQuGmqkXC3VLVQuGmqoXCTVULhZuqFgq3gTsSbqpaKNxUtVC4qWqhcFPVQuGmqkXC3VHVQuGmqoXCTVULhZuqFgq3gTsSbqpaKNxUtVPhTtN3u/cXMPe4qWqhcFPVQuGmqkXCnahqoXBT1ULhpqqFwk1VC4XbwB0JN1UtFG6qWijcVLVQuKlqoXBT1SLhNqpaKNxUtVC4qWqhcFPVQuE2cEfCTVULhZuqFgo3VS0UbqpaKNxUtUi4e6paKNxUtVC4qWqhcFPVQuE2cEfCTVULhZuqFgo3VS0UbqpaKNxUtUi4M1UtFG6qWijcVLVQuKlqoXAbuCPhpqqFwk1VC4WbqhYKN1UtFG6qWiTcA1UtFG6qWijcVLVQuKlqoXAbuCPhpqqFwk1VC4WbqhYKN1UtFG6qWiTchaoWCjdVLRRuqloo3FS1ULgN3JFwU9VC4aaqhcJNVQuFm6oWCjdVLRLuSlU7E+7cpObHsbmp3T1uqloo3FS1ULipaqFwG7gj4aaqhcJNVQuFm6oWCjdVLRRuqlog3NZQ1ULhpqqFwk1VC4WbqhYKt4E7Em6qWijcVLVQuKlqoXBT1ULhpqpFwt1S1ULhpqqFwk1VC4WbqhYKt4E7Em6qWijcVLVQuKlqoXBT1ULhpqpFwt1R1ULhpqqFwk1VC4WbqhYKt4E7Em6qWijcVLVQuKlqoXBT1ULhpqpFwp2oaqFwU9VOhTs14zPLKaV73FS1ULipaqFwG7gj4aaqhcJNVQuFm6oWCjdVLRRuqlok3EZVC4WbqhYKN1UtFG6qWijcBu5IuKlqoXBT1ULhpqqFwk1VC4WbqhYJd09VC4WbqhYKN1UtFG6qWijcBu5IuKlqoXBT1ULhpqqFwk1VC4WbqhYJd6aqhcJNVQuFm6oWCjdVLRRuA3ck3FS1ULipaqFwU9VC4aaqhcJNVYuEe6CqhcJNVQuFm6oWCjdVLRRuA3ck3FS1ULipaqFwU9VC4aaqhcJNVYuEu1DVQuGmqoXCTVULhZuqFgq3gTsSbqpaKNxUtVC4qWqnwp2zjbhz7e9xU9VC4aaqRcJdqWqnwj00dcQ9pPr44NL1oxulu8Exf/CkRPn50C+NqHVotINGVEA02kEj6iIa7aCRoREabdeIGopGO2hEZUWjHTSi3qLRDhpRhdFoB42ozWi0WaO+oWKj0Q4aUbHRaAeNqNhotINGVGw02kEjQyM02q4RFRuNdtCIio1GO2hExUajHTSiYqPRDhpRsdFou0YtFRuNdtCIio1GO2hExUajHTSiYqPRDhoZGqHRdo2o2Gi0g0ZUbDTaQSMqNhrtoBEVG4120IiKjUbbNeqo2Gi0g0ZUbDTaQSMqNhrtoBEVG4120MjQCI22a0TFRqMdNKJio9EOGlGx0WgHjajYaLSDRlRsNNquUaJio9EOGlGx0WgHjajYaLSDRlRsNNpBI0MjNNquERUbjXbQiIqNRjtoRMVGox00omKj0Q4aUbHRaLtGRsVGox00omKj0Q4aUbHRaAeNqNhotINGhkZotF0jKjYa7aARFRuNdtCIio1GO2hExUajHTSiYqPRdo16KjYa7aARFRuNdtCIio1GO2hExUajHTQyNEKj7RpRsdFoB42o2Gi0g0ZUbDTaQSMqNhrtoBEVG422a5Sp2Gi0g0ZUbDTaQSMqNhrtoBEVG4120MjQCI22a0TFRqMdNKJio9EOGlGx0WgHjajYaLSDRlRsNNqu0UDFRqMdNKJio9EOGlGx0WgHjajYaLSDRoZGaLRdIyo2Gu2gERUbjXbQiIqNRjtoRMVGox00omKj0XaNChUbjXbQiIqNRjtoRMVGox00omKj0Q4aGRqh0XaNqNhotINGVGw02kEjKjYa7aARFRuNdtCIio1G2zWqVGw02kEjKjYa7aARFRuNdtCIio1GO2hkaIRG2zWiYqPRDhpRsdFoB42o2Gi0g0ZUbDTaQSMqdmCNUj9p9O0J/exGbkjTcd1Iw3hwsdYeH5yaYXxyqSnXR+7mnpy1/fjsrB3S7cFf1lGyse546wjfWHe8dXRyrDveOsM6rDvcOio81h1vHdEe6463jsaPdcdbx5YA1h1vHTsIWHe4dS17E1h3vHXsTWDd8daxN4F1x1vH3gTWHW+dYR3WHW4dexNYd7x17E1g3fHWsTeBdcdbx94E1h1vHXsTWHe4dR17E1h3vHXsTWDd8daxN4F1x1vH3gTWHW+dYR3WHW4dexNYd7x17E1g3fHWsTeBdcdbx94E1h1vHXsTWHe4dYm9Caw73jr2JrDueOvYm8C6461jbwLrjrfOsA7rDreOvQmsO9469iaw7njr2JvAuuOtY28C6463jr0JrDvcOmNvAuuOt469Caw73jr2JrDueOvYm8C6460zrMO6w61jbwLrjreOvQmsO9469iaw7njr2JvAuuOtY28C6w63rmdvAuuOt469Caw73jr2JrDueOvYm8C6460zrMO6w61jbwLrjreOvYkn1rWtjSvYtuUn775WMGRnN5tW0LI9XkGr/bgYlyt6cnCXhunHMdXrD1nX/1jukIH5fcttZuNyWx5ul3vmkfN4yfbz750vMiEj7BvJlPGRu76pW8jkkKHyfWT6Ov3M5K65+xWVQxa69y330E1/EYabg2d/EC5/occn2Nbm/s9HDtmxRNiErD0+2HRNasaDmz5t+mtjYDwDxpA9wgvGXCaMtd2EMeSAfz6MIStDGroJo/XPOk3bTJ0m5evBZe6Rq43B7bIu/e1yzzzBNBVCS+W+oeWQSUKETcgoocFmCJklRNiEbBgibEI2DBE2IRuGCBuDjVs2IWuDCJuQCUGEDV3ALxu6gF82dAG3bApdwC8buoBfNnQBv2zoAn7ZGGzcsqEL+GVDF/DLhi7glw1dwC8buoBbNpUu4JcNXcAvG7qAXzZ0Ab9sDDZu2dAF/LKhC/hlQxfwy4Yu4JcNXcArm6GhC/hlQxfwy4Yu4JcNXcAvG4ONWzZ0Ab9s6AJ+2dAF/LKhC/hlQxdwy6alC/hlQxfwy4Yu4JcNXcAvG4ONWzZ0Ab9s6AJP2UyfBd52bXckG7qAXzZ0Ab9s6AJu2XR0Ab9s6AJ+2dAF/LKhC/hlY7Bxy4Yu4JcNXcAvG7qAXzZ0Ab9s6AJu2SS6gF82dAG/bOgCftnQBfyyMdi4ZUMX8MuGLuCXDV3ALxu6gF82dAG3bIwu4JcNXcAvG7qAXzZ0Ab9sDDZu2dAF/LKhC/hlQxfwy4Yu4JcNXcAtm54u4JcNXcAvG7qAXzZ0Ab9sDDZu2dAF/LKhC/hlQxfwy4Yu4JcNXcAtm0wX8MuGLuCXDV3ALxu6gF82Bhu3bOgCz9h0fT+xqYeyoQv4ZUMX8MuGLuCXDV3ALZuBLuCXDV3ALxu6gF82dAG/bAw2btnQBfyyoQv4ZUMX8MuGLuCXDV3ALZtCF/DLhi7glw1dwC8buoBfNgYbt2zoAn7Z0AX8sqEL+GVDF/DLhi7glk2lC/hlQxfwy4Yu4JcNXcAvG4ONWzZ0Ab9s6AJ+2dAF/LKhC/hlQxfwyqY0dAG/bOgCftnQBfyyoQv4ZWOwccuGLuCXDV3ALxu6gF82dAG/bOgCbtm0dAG/bOgCftnQBfyyoQv4ZWOwecImpekJpvKETcnjsaVcr7i9LPzXajPp77naNduPY2tpflrtd//UUAXOwZGCcA6O1IZzcKRMnIJjR8U4B0eKxzk4UkfOwZGScg6OBsdTcKTnnIMjPeccHOk55+BIzzkHR3rOKTgmes45ONJzzsGRnnMOjvScc3A0OJ6CIz3nHBzpOefgSM85B0d6zjk40nNOwdHoOefgSM85B0d6zjk40nPOwdHgeAqO9JxzcKTnnIMjPeccHOk55+BIzzkFx56ecw6O9JxzcKTnnIMjPeccHA2Op+BIzzkHR3rOOTjSc87BkZ5zDo70nFNwzPScc3Ck55yDIz3nHBzpOefgaHA8BUd6zp4cL0vQTpfR5ycke8vjRfdW8mOSF5DT2uVb7P3sM2zKeHBq7fbgL+zkn5DYqUUhsROXQmKnRZ0S+/U6Ls9wuMM+kK5CYqd0nRP79IU2yW6+0Wb24K4O4yN3tdQnB5uNQ2dneXh88PX52e3j/pgiB+oc7n3KPYoi7r3mXhkfueubusk9wz3c+5B7lFvce8m9oRu3Aroh25ODm9SMBzd92iQqrRlRJUSljiPqG0XNZRK1tptEpecjqoSo7ECEFzU17XgZqemePHKXhknUdPM17GPkLuxtINRLQu0XGgsbLLj3KffYYMG9T7nHBgvuvebebpG7GO7h3ofcY4MF915yr6/T39zcNffDKxshCLWrUGxYINSuQrGxgFC7CsUGAEK9JNQrO1XtpcmOy1Gb+92Cym4B9n3OPvYLsO9t9u34uqfK5gKiSojKTgSiSohqiIqo7xN1txfoVfY4EFVCVPZOEPXi0Hhw222dztk7QahdhWLvBKFeEWrPeYNtFtz7jHu1YZMF9z7lHlssuPeae3tNpJdbQNzDvQ+5x0bIKd3rbXqGff/kTTuvvQH88ftqa2MIhVAf+QC/2rAHgXufco9tBdz7lHvsQODeZz48sjZsVuDep9xjswL3XnLv8ZuMassOBELtKhTbCgi1q1DsFSDUrkKxAYBQb/sE2CcvdautYR/2fcw+9guwT+D7BGrL5gKiSojKTgSiSojKtgWiCnzxRW3Z40BUBVE79k7Ci/qhD5avHdssuPcp99iRwb3PfLB87di8wb1PuWe4h3v+P0KtduzyIKqEqOzyIKrAR6jVjl0eRJUQlV0eRN3xo9lqx24MQu0pVGLXBKE+9JlXiV0T3PuUe+ya4N6n3GPXBPc+9HlryXAP9z7kHhshu7pXmjFqtaVrf3Lva73p+ceuN1n62PWmrh673sTHt613a/frbbS5Y9ebHnXsetNgjl1vusOx622s95H3J8Z8eex6M18eu97Ml8euN/PlsevNfHnoevfMl8euN/PlsevNfHnsejNfHrvexnofut7Ml0ftnX+tN/PlsevNfHnsejNfHrvezJeHrndmvny23rkbr7nNfX+73l8ryMS4dQWZAbeuIFPd1hU0VnDjCjJ5bV1BZqmtK8h0tHUFmXe2riATzMYVHJhJtq4gM8nWFWQm2bqCzCRbV9BYwY0ryEyydQWZSbauIDPJ1hVkJtm6gswkG1ewMJNsXUFmkq0ryEyydQWZSbauoLGCG1eQmWTrCjKTbF1BZpKtK8hMsnUFmUk2rmBlJtm6gswkz1ZwmD7hrK03XwY0/2rDprsuR5Nuvzvo2/enza3e9ODWXl+dmGafY9uMX8fWtjcf7ng5+Isl09F5WDKnnYelwXJXlimlK0sbnrEs03NsS2k2smR2PQ9LpujzsGSef4XlzRtHZ1mmanV85Hr7sb5znwFsKY9vSbVU0u3BX2woBX7Z0CCcsklNQ93wy4Zu4pcNHcQvG7qGXzYGG7ds6A5+2dAR/LKhC/hlQxfwy4Yu4JZNSxfwy4Yu4JcNXcAvG7qAXzYGG7ds6AJ+2dAF/LKhC/hlQxfwy4Yu4JZNRxfwy4Yu4JcNXcAvG7qAXzYGG7ds6AJ+2dAF/LKhC/hlQxfwy4Yu4JZNogv4ZUMX8MuGLuCXDV3ALxuDjVs2dAG/bOgCftnQBfyyoQv4ZUMXcMvG6AJ+2dAF/LKhC/hlQxfwy8Zg45YNXcAvG7rAEzZd246X0V0e+pbN1woyvW9dwZAz9tCl6TKerWDJ4/Mr5XoR7eXn+WsBQw7CryxgzeMnfNabTwP9toBv/v3ah5yDNdCEHIM10IScgjXQhByCNdAYaLyiCTkCa6AJOQFroAk5WmugYWZ3i4Ya4BVNpga4RUMNcIuGGuAWDTXALRoDjVc01AC3aKgBbtFQA9yioQa4RUMN8IpmoAa4RUMNcIuGGuAWDTXALRoDjVc01AC3aKgBbtFQA9yioQa4RUMN8IqmUAPcoqEGuEVDDXCLhhrgFo2BxisaaoBbNNQAt2ioAW7RUAPcoqEGeEVTqQFu0VAD3KKhBrhFQw1wi8ZA4xUNNcAtGmqAWzTUALdoqAFu0VADnn1Mq6V2euQ+P4HTWx4fureSH8O5sJmWI9+S7OcOvqSb8eDU2u3B30i2DfHgLCRpDWchSZo4C0lKhgrJ63Uks+GepEHyJCTpJDIkp88yT3bzYeazB3d1GB+5q6U+OdhsnJw6y8Pjg6/Pz24fN//QibaDTjvqRI9Cp8uFjgf3Td2kEw0NnXbUie6HTkM3tuFuyPbk4CY148FNn7a411Iqce9T7tFWce8193KZ3KvtJveowbj3Kffo12d0LzXt9Ayb7skjd2mY3Eu1uz34yxHDkfCO7BfAWvI8Ou2oE3kenXbUiTyPTvv11JY8j0476kSeR6e+Tn/sctfcjWsdGR1HnjlC7saRZ46QpXHkmSPkYxx5ZeuiLWVajtrct+bOEAqh9hSK2oxQH3pRSUeaxr1PuUfHxr1PuUf0xr0PvaCpo5Dj3ofcS5T3c7pXp/cbXwLFtnk0Ud5x5JkjlPfwjux4O56I9Oi0o06GTui0n04EenTacQajuaPTjjqR0VV06m2Ekvr+yXsAXntv5pP3xyVyN47s9w6URMFGp/10MqI0Ou2oE/0anfZ7Q5ORutFpR51I3ej05D0LZjiCI08cIUrjyDNHKM048swR8jGO7Pl2JqM1I9SuQlGbEepD7xPpSdO49yn36Ni49yn3iN6496H3KPUUctz7lHuGeyd071Mf1dsT6dFpR53o+ei030sRetI/Ou2oE+EfnT7VK9gjwL0PuZfZI8C9D/WKzB4B7n3KPfYIzunejp8TlGn5OPLMEcOR6I7seTtOc0enHXWiuaPTjjrR3NFpxxmM5o5OO+pERn+mU2nG2NKWrv1Jp+9LOFCDNy8hUXPzEtLmNi8h6eqVJWxtZgmNJdy6hNSMzUvIBL95CZlaNy8hk9rmv8hMJ1uXsDCdbF5CppPNS8h0snkJmU42L6GxhFuXkOlk8xIynWxeQqaTzUvIdLJ5CZlONmzFfV/CynSyeQmZTjYvIdPJ5iVkOtm8hBZxCUszvUiitMPtEn4tSsh549mihJwgni1KyJng2aKEvMt/tigh79sfL0rXhLwTf7YoIe+tny1KyLvlZ4sS8v732aIYi3K/KNzRziwKd7Qzi8Id7cyicEc7syjc0d4vSssd7cyicEc7syjc0c4sCne0M4tiLMr9onBHO7Mo3NHOLAp3tDOLwh3tzKJwR3u/KB13tDOLwh3tzKJwRzuzKNzRziyKsSj3i3KWO1qr48fYtP3NV8HOHlz7+uPYevuZEt++wODu2C5PH0BZr5+Ok+Y+f6JvxifXp+7xoV2u18+1vHk9Tep/YDnLPfXJsJzlrl4LS2qa6SNjmr48Prit/YijrSXdMzzLEBKZ4VlmpsAM01lGvMgMzzKRRmZ4lgE6MsOzzPuRGRoM5RlSU/QZkl70GdJp9BnSafQZ0mnkGRqdRp8hnUafIZ1GnyGdRp+hwVCeIZ1GnyGdRp8hnUafIZ1GnyGdRp5hT6fRZ0in0WdIp9FnSKfRZ2gwlGdIp9FnSKfRZ0in0WdIp9FnSKeRZ5jpNPoM6TT6DOk0+gzpNPoMDYbyDOk0+gzpNPoM6TT6DOk0+gzpNPIMBzqNPkM6jT5DOo0+QzqNPkODoTxDOo0+QzqNPkM6jT5DOo0+QzqNPMNCp9FnSKfRZ0in0WdIp9FnaDCUZ0in0WdIp9FnSKfRZ0in0WdIp5FnWOk0+gzpNB9heFmqcSGstPdYSC+fwPLs20IrNcUlFgOLRyw0D5dYyBgusVAmXGIhNrjEQj9wiOUymoLFIxamfJdYmPJdYmHKd4nFwOIRC1O+SyxM+S6xMOW7xMKU7xILU75HLC1TvkssTPkusTDlu8TClO8Si4HFIxamfJdYmPJdYmHKd4mFKd8lFqZ8j1g6pnyXWJjyXWJhyneJhSnfJRYDi0csTPkusTDlu8TClO8SC1O+SyxM+R6xJKZ8l1iY8l1iYcp3iYUp3yUWA4tHLEz5LrEw5bvEwpTvEgtTvkssTPkesRhTvkssTPkusTDlu8TClO8Si4HFIxamfJdYmPJdYmHKd4mFKd8lFqZ8j1h6pnyXWJjyXWJhyneJhSnfJRYDi0csTPkusTDlu8TClP8JLHt+Y1XqSQL6DOkH8gwzsUGfIWVCnyEZQ58hzUOfocFQniE1RZ8h6UWfIZ1GnyGdRp8hnUae4UCn0WdIp9FnSKfRZ0in0WdoMJRnSKfRZ0in0WdIp9FnSKfRZ0inkWdY6DT6DOk0+gzpNPoM6TT6DA2G8gzpNPoM6TT6DOk0+gzpNPoM6TTyDCudRp8hnUafIZ1GnyGdRp+hwVCeIZ1GnyGdRp8hnUafIZ1GnyGdRp2hNXQafYZ0Gn2GdBp9hnQafYYGQ3mGdBp9hnQafYZ0Gn2GdBp9hnQaeYYtnUafIZ1GnyGdRp8hnUafocFQniGdRp8hnUafIZ1GnyGdRp8hnUaeYUen0WdIp/kIQ+vTuBA2DI8PLhONMpR7glQadYI0GnWCBkFxgvQZdYLUGXWCtBl1gpQZdYJ0GXGCiSqjTpAmo06QJqNOkCajTtAgKE6QJqNOkCajTpAmo06QJqNOkCYjTtBoMuoEaTLqBGky6gRpMuoEDYLiBGky6gRpMuoEaTLqBGky6gRpMuIEe5qMOkGajDpBmow6QZqMOkGDoDhBmow6QZqMOkGajDpBmow6QZqMOMFMk1EnSJNRJ0iTUSdIk1EnaBAUJ0iTUSdIk1EnSJNRJ0iTUSdIkxEnONBk1AnSZNQJ0mTUCdJk1AkaBMUJ0mTUCdJk1AnSZNQJ0mTUCdJkxAkWmow6QZqMOkGajDpBmow6QYOgOEGajDpBmow6QZqMOkGajDpBmow4wUqTUSdIk1EnSJNRJ0iTUSdoEBQnSJNRJ0iTUSdIk1EnSJNRJ0iT0SbYNzQZdYI0GXWCNBl1gjQZdYIGQXGCNBl1gjQZdYI0GXWCNBl1gjQZcYItTUadIE1GnSBNRp0gTUadoEFQnCBNRp0gTUadIE1GnSBNRp0gTUacYEeTUSdIk1EnSJNRJ0iTUSdoEBQnSJNRJ0iTUSdIk1EnSJNRJ0iTESeYaDLqBGky6gRpMuoEaTLqBA2C4gRpMuoEaTLqBGky6gRpMuoEaTLiBI0mo06QJqNOkCajTpAmo07QIChOkCajTpAmo06QJqNOkCajTpAmI06wp8moE6TJqBOkyagTpMmoEzQIihOkyagTpMmoE6TJqBOkyagTpMmIE8w0GXWCNBl1gjQZdYI0GXWCBkFxgjQZdYI0GXWCNBl1gjQZdYI0GXGCA01GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTUadIE1GnGChyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyYgTrDQZdYI0GXWCNBl1gjQZdYIGQXGCNBl1gjQZdYI0mc8QTDYRLO09FkLLJ7B0uU4PO1h/j4V64hBLbkgiLrHQOVxiIV64xEKRcInFwOIRC+3AJRaCgEssTPkusTDlu8TClO8RS8uU7xILU75LLEz5LrEw5bvEYmDxiIUp3yUWpnyXWJjyXWJhyneJhSnfI5aOKd8lFqZ8l1iY8l1iYcp3icXA4hELU75LLEz5LrEw5bvEwpTvEgtTvkcsiSnfJRamfJdYmPJdYmHKd4nFwOIRC1O+SyxM+S6xMOW7xMKU7xILU75HLMaU7xILU75LLEz5LrEw5bvEYmDxiIUp3yUWpnyXWJjyXWJhyneJhSnfI5aeKd8lFqZ8l1iY8l1iYcp3icXA4hELU75LLEz5LrEw5bvEwpTvEgtTvkcsmSnfJRamfJdYmPJdYmHKd4nFwPIBLKlpxueWmr48Prit/YijrSXdMyQJ6DOkH+gzJDboM6RM6DMkY8gzHGge+gwJJPoMqSn6DEkv+gwNhvIM6TT6DOk0+gzpNPoM6TT6DOk08gwLnUafIZ1GnyGdRp8hnUafocFQniGdRp8hnUafIZ1GnyGdRp8hnUaeYaXT6DOk0+gzpNPoM6TT6DM0GMozpNPoM6TT6DOk0+gzpNPoM6TTqDMcGjqNPkM6jT5DOo0+QzqNPkODoTxDOo0+QzqNPkM6jT5DOo0+QzqNPMOWTqPPkE6jz5BOo8+QTqPP0GAoz5BOo8+QTqPPkE6jz5BOo8+QTiPPsKPT6DOk0+gzpNPoM6TT6DM0GMozpNPoM6TT6DOk0+gzpNN8hKH1aVwIG4bHB5eJRhnKPUEqjTjBRKNRJ0ihUSdIn1EnSJ1RJ2gQFCdImVEnSJdRJ0iVUSdIk1EnSJMRJ2g0GXWCNBl1gjQZdYI0GXWCBkFxgjQZdYI0GXWCNBl1gjQZdYI0GXGCPU1GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTUadIE1GnGCmyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyYgTHGgy6gRpMuoEaTLqBGky6gQNguIEaTLqBGky6gRpMuoEaTLqBGky4gQLTUadIE1GnSBNRp0gTUadoEFQnCBNRp0gTUadIE1GnSBNRp0gTUacYKXJqBOkyagTpMmoE6TJqBM0CIoTpMmoE6TJqBOkyagTpMmoE6TJaBMsDU1GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTUadIE1GnGBLk1EnSJNRJ0iTUSdIk1EnaBAUJ0iTUSdIk1EnSJNRJ0iTUSdIkxEn2NFk1AnSZNQJ0mTUCdJk1AkaBMUJ0mTUCdJk1AnSZNQJ0mTUCdJkxAkmmow6QZqMOkGajDpBmow6QYOgOEGajDpBmow6QZqMOkGajDpBmow4QaPJqBOkyagTpMmoE6TJqBM0CIoTpMmoE6TJqBOkyagTpMmoE6TJiBPsaTLqBGky6gRpMuoEaTLqBA2C4gRpMuoEaTLqBGky6gRpMuoEaTLiBDNNRp0gTUadIE1GnSBNRp2gQVCcIE1GnSBNRp0gTUadIE1GnSBNRpzgQJNRJ0iTUSdIk1EnSJNRJ2gQFCdIk1EnSJNRJ0iTUSdIk1EnSJMRJ1hoMuoEaTLqBGky6gRpMuoEDYLiBGky6gRpMuoEaTLqBGky6gRpMuIEK01GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTUadIE1Gm2BtaDLqBGky6gRpMuoEaTLqBA2CHyGYbCJY2nsshJZPYOlynR52sP4eC/XEJRaSiEssdA6XWIgXHrG0FAmXWMgMLrHQDlxiIQi4xGJg8YiFKd8lFqZ8l1iY8l1iYcp3iYUp3yOWjinfJRamfJdYmPJdYmHKd4nFwOIRC1O+SyxM+S6xMOW7xMKU7xILU75HLIkp3yUWpnyXWJjyXWJhyneJxcDiEQtTvkssTPkusTDlu8TClO8SC1O+RyzGlO8SC1O+SyxM+S6xMOW7xGJg8YiFKd8lFqZ8l1iY8l1iYcp3iYUp3yOWninfJRamfJdYmPJdYmHKd4nFwOIRC1O+SyxM+S6xMOW7xMKU7xILU75HLJkp3yUWpnyXWJjyXWJhyneJxcDiEQtTvkssTPkusTDlu8TClO8SC1O+RywDU75LLEz5n8CSmmZ8bqnpy+OD28vW/vjcakn3DEkC+gzpB/oMDYbyDCkT+gzJGPoMaR76DAkk+gypKfIMC+lFnyGdRp8hnUafIZ1Gn6HBUJ4hnUafIZ1GnyGdRp8hnUafIZ1GnmGl0+gzpNPoM6TT6DOk0+gzNBjKM6TT6DOk0+gzpNPoM6TT6DOk04gztKah0+gzpNPoM6TT6DOk0+gzNBjKM6TT6DOk0+gzpNPoM6TT6DOk08gzbOk0+gzpNPoM6TT6DOk0+gwNhvIM6TT6DOk0+gzpNPoM6TT6DOk08gw7Oo0+QzqNPkM6jT5DOo0+Q4OhPEM6jT5DOo0+QzqNPkM6jT5DOo08w0Sn0WdIp9FnSKfRZ0in0WdoMJRnSKf5CEPr07gQNgyPDy4TjTKUe4JUGnWCNBp1ghQadYL0GXGCRp1RJ0ibUSdImVEnSJdRJ2gQFCdIk1EnSJNRJ0iTUSdIk1EnSJMRJ9jTZNQJ0mTUCdJk1AnSZNQJGgTFCdJk1AnSZNQJ0mTUCdJk1AnSZMQJZpqMOkGajDpBmow6QZqMOkGDoDhBmow6QZqMOkGajDpBmow6QZqMOMGBJqNOkCajTpAmo06QJqNO0CAoTpAmo06QJqNOkCajTpAmo06QJiNOsNBk1AnSZNQJ0mTUCdJk1AkaBMUJ0mTUCdJk1AnSZNQJ0mTUCdJkxAlWmow6QZqMOkGajDpBmow6QYOgOEGajDpBmow6QZqMOkGajDpBmow2wbahyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyYgTbGky6gRpMuoEaTLqBGky6gQNguIEaTLqBGky6gRpMuoEaTLqBGky4gQ7mow6QZqMOkGajDpBmow6QYOgOEGajDpBmow6QZqMOkGajDpBmow4wUSTUSdIk1EnSJNRJ0iTUSdoEBQnSJNRJ0iTUSdIk1EnSJNRJ0iTESdoNBl1gjQZdYI0GXWCNBl1ggZBcYI0GXWCNBl1gjQZdYI0GXWCNBlxgj1NRp0gTUadIE1GnSBNRp2gQVCcIE1GnSBNRp0gTUadIE1GnSBNRpxgpsmoE6TJqBOkyagTpMmoEzQIihOkyagTpMmoE6TJqBOkyagTpMmIExxoMuoEaTLqBGky6gRpMuoEDYLiBGky6gRpMuoEaTLqBGky6gRpMuIEC01GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTUadIE1GnGClyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyWgT7BqajDpBmow6QZqMOkGajDpBg6A4QZqMOkGajDpBmow6QZqMOkGajDjBliajTpAm8xmCySaCpb3HQmj5BJYu1+lhB+vvsVBPXGIxsHjEQudwiYV44RILRcIlFjKDSyy0A49YOoKASyxM+S6xMOW7xMKU7xKLgcUjFqZ8l1iY8l1iYcp3iYUp3yUWpnyPWBJTvkssTPkusTDlu8TClO8Si4HFIxamfJdYmPJdYmHKd4mFKd8lFqZ8j1iMKd8lFqZ8l1iY8l1iYcp3icXA4hELU75LLEz5LrEw5bvEwpTvEgtTvkcsPVO+SyxM+S6xMOW7xMKU7xKLgcUjFqZ8l1iY8l1iYcp3iYUp3yUWpnyPWDJTvkssTPkusTDlu8TClO8Si4HFIxamfJdYmPJdYmHKd4mFKd8lFqZ8j1gGpnyXWJjyXWJhyneJhSnfJRYDi0csTPkusTDlu8TClO8SC1P+J7CkphmfW2r68vjgtvYjjraWdM+QJCDPsNAP9BkSG/QZUib0GZIx9BkaDOUZEkj0GVJT9BmSXvQZ0mn0GdJp5BlWOo0+QzqNPkM6jT5DOo0+Q4OhPEM6jT5DOo0+QzqNPkM6jT5DOo06w8tjwVCeIZ1GnyGdRp8hnUafocFQniGdRp8hnUafIZ1GnyGdRp8hnUaeYUun0WdIp9FnSKfRZ0in0WdoMJRnSKfRZ0in0WdIp9FnSKfRZ0inkWfY0Wn0GdJp9BnSafQZ0mn0GRoM5RnSafQZ0mn0GdJp9BnSafQZ0mnkGSY6jT5DOo0+QzqNPkM6jT5Dg6E8QzqNPkM6jT5DOo0+QzqNPkM6jTxDo9PoM6TT6DOk03yEofVpXAgbhscHl4lGGco9QSqNOkGDoDhBCo06QfqMOkHqjDpB2ow6QcqMOMGeLqNOkCqjTpAmo06QJqNO0CAoTpAmo06QJqNOkCajTpAmo06QJiNOMNNk1AnSZNQJ0mTUCdJk1AkaBMUJ0mTUCdJk1AnSZNQJ0mTUCdJkxAkONBl1gjQZdYI0GXWCNBl1ggZBcYI0GXWCNBl1gjQZdYI0GXWCNBlxgoUmo06QJqNOkCajTpAmo07QIChOkCajTpAmo06QJqNOkCajTpAmI06w0mTUCdJk1AnSZNQJ0mTUCRoExQnSZNQJ0mTUCdJk1AnSZNQJ0mS0CVpDk1EnSJNRJ0iTUSdIk1EnaBAUJ0iTUSdIk1EnSJNRJ0iTUSdIkxEn2NJk1AnSZNQJ0mTUCdJk1AkaBMUJ0mTUCdJk1AnSZNQJ0mTUCdJkxAl2NBl1gjQZdYI0GXWCNBl1ggZBcYI0GXWCNBl1gjQZdYI0GXWCNBlxgokmo06QJqNOkCajTpAmo07QIChOkCajTpAmo06QJqNOkCajTpAmI07QaDLqBGky6gRpMuoEaTLqBA2C4gRpMuoEaTLqBGky6gRpMuoEaTLiBHuajDpBmow6QZqMOkGajDpBg6A4QZqMOkGajDpBmow6QZqMOkGajDjBTJNRJ0iTUSdIk1EnSJNRJ2gQFCdIk1EnSJNRJ0iTUSdIk1EnSJMRJzjQZNQJ0mTUCdJk1AnSZNQJGgTFCdJk1AnSZNQJ0mTUCdJk1AnSZMQJFpqMOkGajDpBmow6QZqMOkGDoDhBmow6QZqMOkGajDpBmow6QZqMOMFKk1EnSJNRJ0iTUSdIk1EnaBAUJ0iTUSdIk1EnSJNRJ0iTUSdIk9Em2Dc0GXWCNBl1gjQZdYI0GXWCBkFxgjQZdYI0GXWCNBl1gjQZdYI0GXGCLU1GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTeYzBJNNBEt7j4XQ8gksXa7Tww7W32HpqCcusZBEXGKhc7jEQrxwicXA4hELmcElFtqBSywEAZdYmPJdYmHK94glMeW7xMKU7xILU75LLEz5LrEYWDxiYcp3iYUp3yUWpnyXWJjyXWJhyveIxZjyXWJhyneJhSnfJRamfJdYDCwesTDlu8TClO8SC1O+SyxM+S6xMOV7xNIz5bvEwpTvEgtTvkssTPkusRhYPGJhyneJhSnfJRamfJdYmPJdYmHK94glM+W7xMKU7xILU75LLEz5LrEYWDxiYcp3iYUp3yUWpnyXWJjyXWJhyveIZWDKd4mFKd8lFqZ8l1iY8l1iMbB4xMKU7xILU75LLEz5LrEw5bvEwpTvEUthyneJhSnfJRamfJdYmPJdYjGweMTClP8JLKlpxueWmr48Prit/YijrSXdMyQJ6DOkH+gzJDboM6RMyDOsZAx9hjQPfYYEEn2G1BR9hgZDeYZ0Gn2GdBp9hnQafYZ0Gn2GdBp1hrmh0+gzpNPoM6TT6DOk0+gzNBjKM6TT6DOk0+gzpNPoM6TT6DOk08gzbOk0+gzpNPoM6TT6DOk0+gwNhvIM6TT6DOk0+gzpNPoM6TT6DOk08gw7Oo0+QzqNPkM6jT5DOo0+Q4OhPEM6jT5DOo0+QzqNPkM6jT5DOo08w0Sn0WdIp9FnSKfRZ0in0WdoMJRnSKfRZ0in0WdIp9FnSKfRZ0inkWdodBp9hnQafYZ0Gn2GdBp9hgZDeYZ0Gn2GdBp9hnQafYZ0Gn2GdJqPMLQ+jQthw/D44DLRKEO5I9hTadQJ0mjUCVJo1AnSZ9QJGgTFCdJm1AlSZtQJ0mXUCVJl1AnSZMQJZpqMOkGajDpBmow6QZqMOkGDoDhBmow6QZqMOkGajDpBmow6QZqMOMGBJqNOkCajTpAmo06QJqNO0CAoTpAmo06QJqNOkCajTpAmo06QJiNOsNBk1AnSZNQJ0mTUCdJk1AkaBMUJ0mTUCdJk1AnSZNQJ0mTUCdJkxAlWmow6QZqMOkGajDpBmow6QYOgOEGajDpBmow6QZqMOkGajDpBmow2waGhyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyYgTbGky6gRpMuoEaTLqBGky6gQNguIEaTLqBGky6gRpMuoEaTLqBGky4gQ7mow6QZqMOkGajDpBmow6QYOgOEGajDpBmow6QZqMOkGajDpBmow4wUSTUSdIk1EnSJNRJ0iTUSdoEBQnSJNRJ0iTUSdIk1EnSJNRJ0iTESdoNBl1gjQZdYI0GXWCNBl1ggZBcYI0GXWCNBl1gjQZdYI0GXWCNBlxgj1NRp0gTUadIE1GnSBNRp2gQVCcIE1GnSBNRp0gTUadIE1GnSBNRpxgpsmoE6TJqBOkyagTpMmoEzQIihOkyagTpMmoE6TJqBOkyagTpMmIExxoMuoEaTLqBGky6gRpMuoEDYLiBGky6gRpMuoEaTLqBGky6gRpMuIEC01GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTUadIE1GnGClyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyWgTLA1NRp0gTUadIE1GnSBNRp2gQVCcIE1GnSBNRp0gTUadIE1GnSBNRpxgS5NRJ0iTUSdIk1EnSJNRJ2gQFCdIk1EnSJNRJ0iTUSdIk1EnSJMRJ9jRZNQJ0mTUCdJk1AnSZNQJGgTFCdJkPkMw2USwtPdYCC2fwNLlOj3sYP09FuqJSywkEZdY6BwesSTihUssFAmXWMgMLrHQDlxiMbB4xMKU7xILU75LLEz5LrEw5bvEwpTvEYsx5bvEwpTvEgtTvkssTPkusRhYPGJhyneJhSnfJRamfJdYmPJdYmHK94ilZ8p3iYUp3yUWpnyXWJjyXWIxsHjEwpTvEgtTvkssTPkusTDlu8TClO8RS2bKd4mFKd8lFqZ8l1iY8l1iMbB4xMKU7xILU75LLEz5LrEw5bvEwpTvEcvAlO8SC1O+SyxM+S6xMOW7xGJg8YiFKd8lFqZ8l1iY8l1iYcp3iYUp3yOWwpTvEgtTvkssTPkusTDlu8RiYPGIhSnfJRamfJdYmPJdYmHKd4mFKd8jlsqU7xILU75LLEz5n8CSmmZ8bqnpy+OD29qPONpa0j1DkoA+Q4OhPENigz5DyoQ+QzKGPkOahz5DAok6w9pQU/QZkl70GdJp9BnSafQZGgzlGdJp9BnSafQZ0mn0GdJp9BnSaeQZtnQafYZ0Gn2GdBp9hnQafYYGQ3mGdBp9hnQafYZ0Gn2GdBp9hnQaeYYdnUafIZ1GnyGdRp8hnUafocFQniGdRp8hnUafIZ1GnyGdRp8hnUaeYaLT6DOk0+gzpNPoM6TT6DM0GMozpNPoM6TT6DOk0+gzpNPoM6TTyDM0Oo0+QzqNPkM6jT5DOo0+Q4OhPEM6jT5DOo0+QzqNPkM6jT5DOo08w55Oo8+QTqPPkE6jz5BOo8/QYCjPkE6jz5BO8xGG1qdxIWwYHh9cJhplKPcEqTTqBGk06gQpNOIEM31GnSB1Rp0gbUadIGVGnaBBUJwgVUadIE1GnSBNRp0gTUadIE1GnOBAk1EnSJNRJ0iTUSdIk1EnaBAUJ0iTUSdIk1EnSJNRJ0iTUSdIkxEnWGgy6gRpMuoEaTLqBGky6gQNguIEaTLqBGky6gRpMuoEaTLqBGky4gQrTUadIE1GnSBNRp0gTUadoEFQnCBNRp0gTUadIE1GnSBNRp0gTUaaYN80NBl1gjQZdYI0GXWCNBl1ggZBcYI0GXWCNBl1gjQZdYI0GXWCNBlxgi1NRp0gTUadIE1GnSBNRp2gQVCcIE1GnSBNRp0gTUadIE1GnSBNRpxgR5NRJ0iTUSdIk1EnSJNRJ2gQFCdIk1EnSJNRJ0iTUSdIk1EnSJMRJ5hoMuoEaTLqBGky6gRpMuoEDYLiBGky6gRpMuoEaTLqBGky6gRpMuIEjSajTpAmo06QJqNOkCajTtAgKE6QJqNOkCajTpAmo06QJqNOkCYjTrCnyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyYgTzDQZdYI0GXWCNBl1gjQZdYIGQXGCNBl1gjQZdYI0GXWCNBl1gjQZcYIDTUadIE1GnSBNRp0gTUadoEFQnCBNRp0gTUadIE1GnSBNRp0gTUacYKHJqBOkyagTpMmoE6TJqBM0CIoTpMmoE6TJqBOkyagTpMmoE6TJiBOsNBl1gjQZdYI0GXWCNBl1ggZBcYI0GXWCNBl1gjQZdYI0GXWCNBltgm1Dk1EnSJNRJ0iTUSdIk1EnaBAUJ0iTUSdIk1EnSJNRJ0iTUSdIkxEn2NJk1AnSZNQJ0mTUCdJk1AkaBMUJ0mTUCdJk1AnSZNQJ0mTUCdJkxAl2NBl1gjQZdYI0GXWCNBl1ggZBcYI0GXWCNBl1gjQZdYI0GXWCNBlxgokmo06QJqNOkCbzGYLJJoKlvcdCaPkEli7X6WEH6++xGFg8YiGJuMRC53CJhXjhEgtFwiUWMoNHLEY7cImFIOASC1O+SyxM+S6xGFg8YmHKd4mFKd8lFqZ8l1iY8l1iYcr3iKVnyneJhSnfJRamfJdYmPJdYjGweMTClO8SC1O+SyxM+S6xMOW7xMKU7xFLZsp3iYUp3yUWpnyXWJjyXWIxsHjEwpTvEgtTvkssTPkusTDlu8TClO8Ry8CU7xILU75LLEz5LrEw5bvEYmDxiIUp3yUWpnyXWJjyXWJhyneJhSnfI5bClO8SC1O+SyxM+S6xMOW7xGJg8YiFKd8lFqZ8l1iY8l1iYcp3iYUp3yOWypTvEgtTvkssTPkusTDlu8RiYPGIhSnfJRamfJdYmPJdYmHKd4mFKf8TWFLTjM8tNX15fPDlBmDEcfkxSr8y7BqSgD5D+oE+Q2KDPkPKhD5Dg6E8Q5qHPkMCiT5Daoo+Q9KLPkM6jTzDlk6jz5BOo8+QTqPPkE6jz9BgKM+QTqPPkE6jz5BOo8+QTqPPkE4jz7Cj0+gzpNPoM6TT6DOk0+gzNBjKM6TT6DOk0+gzpNPoM6TT6DOk08gzTHQafYZ0Gn2GdBp9hnQafYYGQ3mGdBp9hnQafYZ0Gn2GdBp9hnQaeYZGp9FnSKfRZ0in0WdIp9FnaDCUZ0in0WdIp9FnSKfRZ0in0WdIp5Fn2NNp9BnSafQZ0mn0GdJp9BkaDOUZ0mn0GdJp9BnSafQZ0mn0GdJp5BlmOo0+QzqNPkM6jT5DOs1HGFqfxoWwYXh8cJlolKHcEzQIihOk0agTpNCoE6TPqBOkzqgTpM2IExwoM+oE6TLqBKky6gRpMuoEDYLiBGky6gRpMuoEaTLqBGky6gRpMuIEC01GnSBNRp0gTUadIE1GnaBBUJwgTUadIE1GnSBNRp0gTUadIE1GnGClyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyWgTTA1NRp0gTUadIE1GnSBNRp2gQVCcIE1GnSBNRp0gTUadIE1GnSBNRpxgS5NRJ0iTUSdIk1EnSJNRJ2gQFCdIk1EnSJNRJ0iTUSdIk1EnSJMRJ9jRZNQJ0mTUCdJk1AnSZNQJGgTFCdJk1AnSZNQJ0mTUCdJk1AnSZMQJJpqMOkGajDpBmow6QZqMOkGDoDhBmow6QZqMOkGajDpBmow6QZqMOEGjyagTpMmoE6TJqBOkyagTNAiKE6TJqBOkyagTpMmoE6TJqBOkyYgT7Gky6gRpMuoEaTLqBGky6gQNguIEaTLqBGky6gRpMuoEaTLqBGky4gQzTUadIE1GnSBNRp0gTUadoEFQnCBNRp0gTUadIE1GnSBNRp0gTUac4ECTUSdIk1EnSJNRJ0iTUSdoEBQnSJNRJ0iTUSdIk1EnSJNRJ0iTESdYaDLqBGky6gRpMuoEaTLqBA2C4gRpMuoEaTLqBGky6gRpMuoEaTLiBCtNRp0gTUadIE1GnSBNRp2gQVCcIE1GnSBNRp0gTUadIE1GnSBNRpugNTQZdYI0GXWCNBl1gjQZdYIGQXGCNBl1gjQZdYI0GXWCNBl1gjQZcYItTUadIE1GnSBNRp0gTUadoEFQnCBNRp0gTUadIE1GnSBNRp0gTUacYEeTUSdIk1EnSJNRJ0iTUSdoEBQnSJNRJ0iTUSdIk1EnSJNRJ0iTESeYaDLqBGky6gRpMuoEaTLqBA2C4gRpMuoEaTLqBGky6gRpMuoEaTKfIZhsIljaOyxGaPkIlmLTD1b5+XG/sFBPXGIhibjEQudwicXA4hELRcIlFjKDSyy0A5dYCAIusTDle8TSM+W7xMKU7xILU75LLEz5LrEYWDxiYcp3iYUp3yUWpnyXWJjyXWJhyveIJTPlu8TClO8SC1O+SyxM+S6xGFg8YmHKd4mFKd8lFqZ8l1iY8l1iYcr3iGVgyneJhSnfJRamfJdYmPJdYjGweMTClO8SC1O+SyxM+S6xMOW7xMKU7xFLYcp3iYUp3yUWpnyXWJjyXWIxsHjEwpTvEgtTvkssTPkusTDlu8TClO8RS2XKd4mFKd8lFqZ8l1iY8l1iMbB4xMKU7xILU75LLEz5LrEw5bvEwpTvEEvfMOW7xMKU7xILU75LLEz5LrEYWDxiYcp3iYUp/xNYrMnjJVjb5ccHt7UfcbS1zDAkCXyCYd/UcYX7NjX3WEgCLrGQBDxiaUkCLrGQBFxiIQm4xEIScInFwOIRC0nAJRaSgEssTPkusTDlu8TClO8RS8eU7xILU75LLEz5LrEw5bvEYmDxiIUp3yUWpnyXWJjyXWJhyneJhSnfI5bElO8SC1O+SyxM+S6xMOW7xGJg8YiFKd8lFqZ8l1iY8l1iYcp3iYUp3yMWY8p3iYUp3yUWpnyXWJjyXWIxsHjEwpTvEgtTvkssTPkusTDlu8TClO8RS8+U7xILU75LLEz5LrEw5bvEYmDxiIUp3yUWpnyXWJjyXWJhyneJhSnfI5bMlO8SC1O+SyxM+S6xMOW7xGJg8YiFKd8lFqZ8l1iY8l1iYcp3iYUp3yOWgSnfJRamfJdYmPI/giVNX43UXxbwHgtTvkssBhaPWJjyXWJhyneJhSnfJRamfJdYmPI9YilM+S6xMOW7xMKU7xILU75LLAYWj1iY8l1iYcp3iYUp3yUWpnyXWJjyPWKpTPkusTDlu8TClO8SC1O+SywGFo9YmPJdYmHKd4mFKd8lFqZ8l1iY8h1iyQ1TvkssTPkusTDlu8TClO8Si4HFIxamfJdYmPJdYmHKd4mFKd8lFqZ8j1hapnyXWJjyXWJhyneJhSnfJRYDi0csTPkusTDlu8TClO8SC1O+SyxM+R6xdEz5LrEw5bvEwpTvEgtTvkssBhaPWJjyXWJhyneJhSnfJRamfJdYmPI9YklM+S6xMOW7xMKU7xILU75LLAYWj1iY8l1iYcr/BJbcpPFyc1O7eyxM+S6xMOW7xMKU7xGLMeW7xMKU7xILU75LLEz5LrEYWDxiYcp3iYUp/yNYUjOu2qUWp3ssTPkusTDlu8TClO8RS8+U7xILU75LLEz5LrEw5bvEYmDxiIUp3yUWpnyXWJjyXWJhyneJhSnfI5bMlO8SC1O+SyxM+S6xMOW7xGJg8YiFKd8lFqZ8l1iY8l1iYcp3iYUp3yOWgSnfJRamfJdYmPJdYmHKd4nFwOIRC1O+SyxM+S6xMOW7xMKU7xILU75HLIUp3yUWpnyXWJjyXWJhyneJxcDiEQtTvkssTPkusTDlu8TClO8SC1O+RyyVKd8lFqZ8l1iY8l1iYcp3icXA4hELU75LLEz5LrEw5bvEwpTvEgtTvkMsQ8OU7xILU75LLEz5H8GSs41YLkPKPRamfJdYDCwesTDlfwTL0IyXkIdUHx9cun5kWLqbZZs/eEJXfj70Czf1IBRuqkQo3NSOULipKJFwt9SZULipPqFwU5NC4aZShcJt4I6Em6oWCjdVLRRuqloo3FS1ULipapFwd1S1ULipaqFwU9VC4aaqhcJt4I6Em6oWCjdVLRRuqloo3FS1ULipapFwJ6paKNxUtVC4qWqhcFPVQuE2cEfCTVULhZuqJoA79RPuku8Zksr8M0zDeHCx1h4fnJohjUvclHrz7OaWuO3HZ2ftkG4P/rKDsoYdy3YQ4rBj0Q6j22HHsh1kPuxYtoMqiB3LdhARsWPZDsMO7Fi0g0SJHct2UDSxY9kOWil2LNtBK8WOZTtopdixaEdPK8WOZTtopdixbAetFDuW7aCVYseyHYYd2LFoB60UO5btoJVix7IdtFLsWLaDVoody3bQSrFj0Y5MK8WOZTtopdixbAetFDuW7aCVYseyHYYd2LFoB60UO5btoJVix7IdtFLsWLaDVoody3bQSrFj0Y6BVoody3bQSrFj2Q5aKXYs20ErxY5lOww7sGPRDlopdizbQSvFjmU7aKXYsWwHrRQ7lu2glWLHoh2FVoody3bQSrFj2Q5aKXYs20ErxY5lOww7sGPRDlopdizbQSvFjmU7aKXYsWwHrRQ7lu2glWLHoh2VVoody3bQSrFj2Q5aKXYs2+G3lfbNjR03X6U7b0c3dOM1X/73zYIPdY55d1mYkXpnZreHfy2MsTDzC+O3kL24MLUff47a1DT1/pnO1p526MYv9L78QD15rkM/XtBw88PXNu3c1efpqfa52GZOg+rVX/7j3//rL3/961/+9//469//48//+Mvf//bf305uvv0/7ax+eQKf640llyd4WYs2v37K8Pop5fVT6sundM2Lp1z+q/12ZDd7k2hpPNHK9Q9aa933f6t7/ZT0+in2+in966fk108ZXj+lvH5KffmUNOtAP/026/P9Ke3rp3Svn5JeP2WWfn/9XTLku1P610/Jr58yvH7KLP2+Tj+bTXN3Sn35lPnveX58Svv6Kd2zU8rdKen1U+z1U+Z///fjLUXO/d0p+fVThtdPKa+fMv/7f2imwaH+esr8N9c8PqV9/ZTu9VNm6ec63m0MTbo7xV4/pX/9lPz6KcOTU9r27pTy+in15VMWPotzGnaHfPfzsvABjQ9P6V4/Jb1+yvyANc22w/0fvoUPfXp4Sn79lOH1U+b3dur4x6I0d38sFj5I4tEpC58u8PCU9vVTuien3PSJ8ZT0+in2+imz9EsefymVfPdLaf69TY9PGV4/pbx+yiz9Mow/+6XcPf3510s/PqV9/ZTu9VNm6Zc6Fbjm7unPvwbr8Sn966fk108ZnpzSDnenlNdPqS+fMr8DVEuaMufdX7H5bYHHp3Svn5JePOXyX923I2eXrcvj7VL30y3GVxVI3wPAwl5YP/16vkmi/WwSLeNsldrHh+6YWttW87I7zctOmpdtmpfda1521rzsQfOyy7su+/elkrrTg3fNOx9889+Fqf3aTV778eDdOx88vfPB7Z0Pvvn31bQVbfUOaH7ngw/vfPCtP6H9tKnTt/nXB69vfPDUvPPB23c++FYV+zSOZn26e/D8zgffCjTbMKXR5pcHt+adD25vXBbbDHT6I9rfFOMfD57f+eDDOx+8vPPB6xsfvG/e+eDtOx+82+/BB/v1wdM7H3zzT2g//YSWuwff/BM6/W6ZefD8zgcf3vngW39Ccztt2930qx8PXt/44Ll554O373zwrT+huUnTg5dfHzy988HtnQ/ev/PB8zsffHjng5d3Pnjd78G7Xz0fmnc++Oaf0GZ87WJOdw+++W/otJ878+DpnQ9u73zwzT+hD+7Ph/zOBx/e+eDlnQ/+zoGrvHPgKu07H7x724Nf/sO+Hbjw8rFh+sP+0+va8oOXjy2fcvmv/tuR8zsXuYz7YoPd7qfNvRLXrjfWP72CpF3eYdjv4fv3Pnx+78MP73348t6Hr299+IVXHu/28O17H77b+vB9O81OfXlybNuksfi3jd388UxluZx/6mLM08X0ni4mH3sx/fQ+nSa3dxczeLqY4uliqqOLSc2xFzNMb6VqSn93Ma2ni+k8XUzydDH2sYu5eXHWeDG9p4vJni7m2N/Al18048W0Ny+GHS+meLqY6uhirHFzMZf/yt9nutlLai+PPp7aD+XxkFrKODmWao8PffuLFhUuvFO98KR64aZ64b3qhWfVCx9UL7y878J/Xwo4uz1817z34bf/rajd+Ee6pnoY1a5TvfCkeuGmeuG96oVn1QsfVC+8vO/Cf1+KXrs9fGre+/Dtex++e+/Dp/c+vL334fv3Pnx+78MPb3142y5m27TTJyw1Xfr1H+je/Q9sx9t2/RhAvn162K//QHn3M6hv/gf6PRiU5poK717tmN79D9i7/4H+3f9Afvc/MOzwDwzXrZ766wvm+vLuf6C++R/Izbv/gfbd/0D37n8gvfsf2OEn+fL7ekrQ/a9v6sr9u/+B/O5/YHj3P1De/Q/UN/8DQ/Puf2CHn+R2+kyItq2/3ngN3bv/gXffFw353f/A8O5/oLz5HyjNu/+B9t3/QPfufyC9+x+wt/4Dl/8Yvh26sOWZbfolk3N+8s9Ye/2c4O7X57Gw3/TaPzB9Pllr5cnBrjanzvYsc4hnOYR4liXEs6wRnmXXhHiWbYhn2Tl5lr8vblx+5lrM0bUc/Nfe1V7k2Z7lEOJZlhDPskZ4lqkJ8SzbEM+yc/Isf1/cLv/MtZija/Hy1/73xV37z1yLl7+cvy+9zeJD1+Llr9DvS2+y+NC1ePmN/vviqy/edi1PXkmRXV3Nwf4+7uB952lt+uTqag73ZsUrOT51NcXV1VRPV5MbV1fTHn01K16q8qmrSa6uxlxdTe/qarKrqxlcXc3Rv4vXvMrnQ1czNK6upnV1NZ2rq0mursZcXc3Rv4sfv4Ysu7oaV/NUaVxdTevqapKrqzFXV9O7uprs6moGP1dz+Y/y7dCF38hNnn5TNfm6r50e/d58fM6w4pyy4pz6+jkLv+sen9OuOKdbcU5acY6tOGeFB2WFB2WFB2WFB2WFB3WFB3WFB3WFB3WFB3WFB3WFB3Xeg3b6pPzL/+p+PWdYcU5ZcU59/Zy2mRehnb4C9nInd39Su+akbs1Jac1Jtuakfs1Jec1Jw5qTFoSYvnC+7Zr7k+qKkxY+gKrrph+LrrO7k+aXvJu+Q77tcro7aVhx0sIrO9P1A/BSvXtOCy+UfHLSvBHdcL3TuPlExPGk/Oyk1DR3J9UVJy286OXJSQsLYZMR6ebTZMeTujUnpTUn2ZqT+jUn5TUnDWtOKmtOmjciTd/Hdlnf8utJC1vbT05q15zUrTkprTnJ1pzUrzkprzlpWHNSWXPSGiP6NUb0a4xY2JR+/Bt2Ye/4yUm25qR+zUl5zUnDmpPqipPymr+Eec1fwrwGbn4Z7uU/6rdDF27gLE3fjGGp3L2vZf4G7tlJec1Jw5qTypqT6oqT5t/A+Oykds1J3ZqT5r86qOnG2jM0938PF75e/MlJ/ZqT5r8I53IzNZ7UzpxUV5y08F2+7dBPJw3DH7u/fHLSwpfMdmVaiNTkP3ar+Oykbs1Jac1Jtuaksmb1FuDW6V/q2uGP3Ys9O6ldc5KtOalfc9K8e12ePqC6y8Mfu0MaOmuuJ6U/dof07KS64qSF70h9clK75qRuzUlpzUm25qR+zUl5zUlrjOjXGNGvMSKvMSKv+WWZ1/yyzGt+WeY1vywXvsvyyUl5zUllzUl1xUnDmr+Ewxq4w8tw//Wn75898c/FW9nH7+teuJV9ctKw5qSy5qS64qSFW9knJ7VrTurWnJTWnDT/s9hPLyYZemv/4K3sk5PympOGNSeVNSfVFSfN599nJ7VrTurWnDT/27mf3h439DPNeMGI6QWEQ19/Ci4zb8CrNv5eSfX269Rn34D3eEBbmEs+djnZ1+UMvi6n+Lqc6upyFgbfj11O6+tyOl+Xk3xdjq/fysnXb+X06m/l3xf3z56dVFacZAtfrdxOd9+5u/vjbWnNSfMLUev4F7807d027EIUeXJSWXNSXXFSv2b1FlLFkKb7pcu907/+WKp4ctL8QpTpFQpDuXl76+MWUKYXGQ5luJ8xmzUnLRjRTJdXG/uD02y9PqfaN39wmn0Md2GafXJSt+aktOYkW3PSmiUfhjUnLfwQputJdufeUFectPC99k9Oatec1K05aQFufz0p3006xdac1K85Ka85aVhzUllzUl1xUm3WnNSu+MVSuzUnpTUn2ZqT+jUn5TUnDWtOKmtOWvEHoGuaNSe1a07q1pyU1pxka07q15yU15xUX79j6eY75rOT5jkN01/Cy/+0u5PmOQ15uJ5095wWtuSfnGRrTurXnJTXnDSsOamsOamuOGmhYz45qV1z0hojujVGdGuM6NYYsdAEH04A3UK5e3JSWXNSXXHSQqt6ctKK+/IupTUn2ZqT+jUnvTxR/+tP37/v+Z+/9f2K93T0fV5z0rDmpLLmpBXv7+lzs+akds1J3ZqT0pqTbM1Ja4zIa4zIa4zIa4zIa4wY1hgxrDFiWGPEsMaIYY0Ra94H2g8r3vjVD8Oak8qak1a896svK9771Zd2zUndmpPSmpNszUn9mpPympOGNSeteO9XX1a896uvK9771S+89/Lh27j6uuK9X7lZ8Yr33LRrTlrx3q/crHjvV25WvPcrt82ak1a89yu33ZqT0pqTbM1J/ZqT8pqThjUnlTUnrXinT+6aNSe1a07q1pyU1pxka07q15yU15w0rDmprDlpjRFpjRFpjRFpxduDckprTrI1J/VrTsprThrWnLTivV/Z1vwltDV/CW0NXFvz3q9vf2ouI/z83nia7lvsZo/jsmX//W5ifmv8wTn/uvzn//vn//rLn//9r//535dTvv1f/+/f/uMff/n733785z/+v//z9X+5HPz/Aw==","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","unsafe_rand","decompose_hint","notify_created_note","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","build_msg_block_iter","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]},{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_counter"]},{"name":"increment","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7b3djuPKmWD7LvvaF2TEF8Fgv8rBxsDd0zMwYNiDbs8BDgy/+1FVFpmqEiltUaHk97NuBt7TpIqKtTKT3wr9/PO3//mf//5///f/+Mvf/tff//u3f/t//vnbX//+H3/+x1/+/rfLf/3zt1G+///99//589++/ed//+PP//WP3/5tnJL86bf//Nv//PY/s/zrT7/9r7/89T9/+7dp+Nefbg5O81h/HJzm3NaD57xxcC7z9OPgXL893L2Dx2GahuU6hql9Xkiq09bxrY7L4a19Pvi3Z3B78Disz3Es+frg3//021hYl811qazL5rpML69LbmNanmqTz3WZ5u//QHv3PzC//A+MKS9kxzSN68HjMG4cPadp/nH0nOZ6fTkb0iQZy2JNEpFfrj4Npq9+3Lr6OaVV5jRdX/y3U9LmE75Yv57T5vtPeE6L/fP10y1bT3cs6w/W/GlOmjcft7S8PHCV9OCHcC4romG4OvhjYXKIZykvP8vLL6dV3nHID55nnur6iyDff+BalkPrdPVLL39IWKxeeLV64ZPVC2+PLvzyg/HowqfPH6KrX7nf/oWtX+ey/nFPrVz9Os/fr2fWdT15UHY9o7LrSV99PVmWO88xX90cfv+R2fgL32T9A3/1t+Pyb27eS7Z5vezrK9m81Rjnsh49Xx2989htWJekpc+/eOn7fWrOLGOPZRSWsccyFpbxDy5jWv9mtzz/uoyVZeyxjBPL2GMZG8v4x5ZxquvRTYZfl3EOu4xpGJfROg0lvfQnRgaWsccyjixjj2WMO8U8u4z3/sRI3Cmm6zIKy9hjGeNOMU8u490bHgk9xbTPZcw/Pfa3lQk9mNxdmbizRhrWH6Z0if6v3ZZEnjX6LWOJPGt0XMbIs8Zzy3jvtqREnjU6LmPkWaPjMgrL+MeW8e5Ncgm9Y9I+l3H+9VawMD7srUzc8SGNaX3d3Vhfa3cl8KzRcxkDzxodl7EGnjWeXMZ7tyU18KzRcxkDzxo9lzHwrPHcMt69Sa7CreD3ZbzppZXxYW9llI8PWdaVkVwercyQ5vXXzJCvRoKdN0Ll9V1Wo4xXV/78G6Gq8mHDzDoqnzbMrKPyccPKOk7K5w0z66h84DCzjsonDjPrqHzkMLOOwjp2WUflE4qZdWSe6bOOzDN91pF5ps86Ms90WcfGPNNnHX3NMznnz3WU6dE69vsAoeZrnjlvHe3OM9+uXr786tdtl1GGR1c/5rJyKul620WbBYV17LKOlXXsso5fP0WsH7J3s47frqfD3fj4uZhjLY+u5/6nu7RZ1/XMg7LrGZVdT1J2Pfmrr8fl57HMwjL2WMbCMvZYxsoy/vb657HME8vYYxkby9hjGWeW8bfXPx3oskhh17HnB7KMw8g6dlnHxDp2Wce4k0zPz2S51BjWscs6xp1l+q5j3GGm54cEXc6JfP9477NwxiH0hHJ/aeJOHT0/meWySqxjl3WMPHX0XMfIU0e/D2e5rAHr2GUdhXXsso6Rp45+nxY0jqG3UO59KM44MkjsLk3cQaLnR7SMY+Cpo+c6psBTR9d1DDx1dPyUljEFnjq6rmPgqaPrOgrr+NvrHxs0ptCv27r36ThjYpDYXRrlg4SVd5KNSfnYYWchlc8dZhYyKx887Cyk8snDzkIqHz3sLKTy2cPOQgoL2WchlU8fdhZS+axiZyGZbDotJJNNp4VksumzkOJrsjntjf2j+JpsTlxIu5PN98v/+nnC5SdljD2+lJiF/LaQXz9P3P3MkbHHF/ymKS0Hpzk/uKCWl4Pb1cpv/+rL83IVkq+oti0H5mlcjJmnqx2BbaZ53Wy4fuRNomlaP+MlTa09wN/TlQ53+kmGTzQPP5+mzatZ83B9dP24oA53zPnz7krG8dEFVVl/C9T56vd7qRtHT/Nq1iifx45t69hh+TMz/XQV9cVjZVgtlKF8ypLmjxWcWcFHK3j5dbKs4DjNv65gj6/zje1gj2/yDe5gYgVfdDCzgi86KKzgg2PzNC6LkacqV1PBxwoW1SvYPrvSIPNPS/j96quZq79+Bdhy9ZPqq79cyHr0ME8P/C1lWO75Sxk/f9d9+6G9OTglWX8zXv63yPXh35dG9032qUvT+e45y4OlyXVaf4FcvX4tbR0rdV5Grcv//PyBbZuTX1rffT+m9OilcbHH4Dqopl7X+5zaHlCfy7Ssylzm4f5Pw9zyCrJNNz8LdWRVNlYlsSobq5JZlY1VkZCrctngzOszHFKrN+tSWJfNdalB16Xm4fNe/qrZbx4e/F5lwpGhXg18y89OY10210X3RHPaukwx7/kvT7CuW6lDG27+Bk0x7/ofr0vM+/7H6xLzzv/xugjrsrkuUe/9H61L1Hv/R+sS9X730bpEvd99tC5R73cfrEvjfnd7Xbjf3V4X7ne314X73e11EdZlc124391eF+53t9eF+93tdeF+d3tduN/dXJeZ+93tdeF+d3tduN/dXhfud7fXRViXzXXhfnd7Xbjf3V4X7ne314X73e114X53a13SwP3u9rpwv7u9Ltzvbq8L97vb6yKsy+a6cL+7vS7c726vC/e72+vC/e72unC/u7kuI/e72+vC/e72unC/u70u3O9ur4uwLpvrwv3u9rpwv7u9Ltzvbq8L97vb68L97ua6JO53t9eF+93tdeF+d3tduN/dXhdhXTbXhfvd7XXhfnd7Xbjf3V4X7ne314X73c11ydzvbq8L97vb68L97va6cL+7vS7CumyuC/e72+vC/e72unC/u70u3O9urwv3u5vrItzvbq8L97vb68L97va6cL+7vS7CumyuC/e72+vC/e72unC/u70uqu935/UDmMtQxvvr8u37mddnWof7B+ciy9ds5HL1LVR5ew3L52KU6wf+voKq74wtrGBRfQ9tYgVV320/tYKprd9/I/XBr8I0r18Zmy7/yOfBW78KS1q/eazk6yX8+EVYVN+Ya1nCqX4uYb1/8P0v+ktF9Q2/xfW++7WAqffXArpc78/vFi+5DA/WW8r6hRZydR+WNn/X3/3GwVRUTzPu4TRZLiO3DTiqR6rocFTPddHh+BkuHcLxM7f6g6P7qy2jw2HaVgyHOV4xHIZ+xXAkJJw8TOuqXH9v+fZ6zysbuUJTtjiuX55err47chzq83lA9xev+ibz4GcmZhuwQCZmGLBAJmYVsEAmZhIwQEb3196GJhMzBlggE7MEWCATMwNYICOQ6UimDstS1FwekGl1Oba1z+c2tvwBhgRwFpi5yo9j5+sfr7b1Or08y/ICwMtqfz5y2npgyZ8v+83fHu7z4O/IaQvhkBMtwiGnhoRDTmaJhlz317iD/B3ICUPhkFOcwiEnZYVDLiCPhpz6Fg459S0ccupbOOTUt3DIqW/RkM/Ut3DIqW/hkFPfwiGnvoVDLiCPhpz6Fg459S0ccupbOOTUt3DIqW/BkOeB+hYOOfUtHHLqWzjk1LdwyAXk0ZBT38Ihp76FQ059C4ec+hYOOfUtGvKR+hYOOfUtHHLqWzjk1LdwyAXk0ZBT38Ihp76FQ059C4ec+hYOOfUtGvJEfQuHnPoWDjn1LRxy6ls45ALyaMipb2chvyzWuF5wqQ+gF6l5vYpW70O/MF9XuV4bsnXNF07rV3NeAvz1wd8NIdZhyH1DaHsYct8QUiCG3DeEchjekM/ryCLTr4ZkQiOG3DeELokh63cMZrn6ksHNg9M8LY+c5jY/OFhkmdCT1On+wZ/PT64f92PkzrRUNDWgKf0XTd+naVseOZVhfkVTQVM01a8pnR1N36bplJaVS1OVBwcPeVgOHkp+xWl2BnDam9PsZeC0EqdrW52ex1ecZvcFp705zX4RTj/hdB7GvC5cevDIKU+r03lO1wd/c0/YicK9t7nXLeAK22FoakBTtsPQ1ICmbIeh6fs07bXPIIKmaKpfU7bD0PRtmpZ5/aNf03AzvrNthXtnucf2Eu6d5R7bQLh3lnts1+De29x7ZgtybG1djnm42dsp7O0gqglR2d1BVBWi9nvxXWErCKe9Oc2+EU57c1pwGqd1ON3rBaWFHSmc9uY0O104/ZTT8/r5KmN6sU+w04V7Z7nHThfuvcu9jmMUm2Joql/TypYYmhrQlA0xNH2fpr1m8soeF5oa0JRtq/CaFlnXopQH75177jMj7r+/vgru4d673Ov2jtDKjhGaGtCUTSA0NaAp+0Vo+j5Ne71xubK1hKYGNGVrCU3fpun99/pN7Bfh3lnusQmEe2e5x84O7p3lHts1uPc29zq+bXkSREVUC6Kyu4OoKkTt9xK5ia0gnPbmNPtGOO3NaTaZcFqJ071eUDqxI4XTzpxu7HTh9BNOn/TVJY1NMTQ1oCn7Z2j6Pk17vbSqsdWGpgY0FTRF03dpek4Xa+zJ4bQ3p9mTw2klTnfrYuzJ4bQ3p9mTw+mnnO73eZaNvTPcO8m9mT0u3HuXe/3GqJk9LjQ1oCl7XGhqQFP2uND0fZr2mslnQVM01a8p21anadqG5XHHlsafNP2Oht0XtWjYRFCLhhauFg2pWAWaUX5FIwMlVS0a6qFaNBQztWioRGrRCGi0oqEGKL15loEaoBYNNUAtGmqAWjTUAK1oRmqAWjTUALVoqAFq0VAD1KIR0GhFQw1Qi4YaoPHVRd/RUAPUoqEGqEVDDdCKJlED1KKhBvREM62v123j8ABNHeYF49WrdfPHy2ol0QKUgqEEKAUjgNEJhgqgFAwNQCkYCoBSMMz/SsEw/esEk5n9lYJh8lcKhslfKRgmf6VgBDA6wTD5KwXD5K8UDJO/UjBM/krBMPnrBCNM/krBMPkrBcPkrxQMk79SMAIYnWCY/JWCYfJXCobJXykYJn+lYJj8dYIpTP5KwTD5KwXD5K8UDJO/UjACGJ1gmPyVgmHyVwqGyV8pGCZ/pWCY/HWCqUz+SsEw+SsFw+SvFAyTv1IwAhidYJj8lYJh8lcKhslfKRgmf6VgmPx1gpmY/JWCYfJXCobJXykYJn+lYAQwOsEw+SsFw+SvFAyTv1IwTP5KwTD56wTTmPyVgmHy7wmmzcs1zA+/diHV5WHTnD9Xbethy7AsWsnp/qG5yXIJuf38uN95ExRi8aZTxOIt8A7Fm6oSizexJhZvGlAs3qSlWLwpVqF4z4SwWLzpa7F409di8aavxeIt8A7Fm74Wizd9LRZv+los3vS1WLzpa5F4l4G+Fos3fS0Wb/paLN70tVi8Bd6heNPXYvGmr8XiTV+LxZu+Fos3fS0U75G+Fos3fS0Wb/paLN70tVi8Bd6heNPXYvGmr8XiTV+LxZu+Fos3fS0U70Rfi8WbvhaLN30tFm/6WizeAu9QvOlrsXjT12Lxpq/F4k1fi8WbvhaKd6avxeJNX4vFm74Wizd9LRZvgXco3vS1WLzpa7F409di8aavxeJNXwvFW+hrsXjT12Lxpq/F4k1fi8Vb4B2KN30tFm/6mi/eMtT5x7Eypnr/4HEuyzKMc7uVgxiHHLtyUO6QY1cOMh9y7MlRaILIsSsHARE5duWgNiLHrhykSeTYlUOQAzn25CB6IseuHBRS5NiVg0KKHLtyUEiRY1cOCily7MlRKaTIsSsHhRQ5duWgkCLHrhwUUuTYlUOQAzn25KCQIseuHBRS5NiVg0KKHLtyUEiRY1cOCily7MkxUUiRY1cOCily7MpBIUWOXTkopMixK4cgB3LsyUEhRY5dOSikyLErB4UUOXbloJAix64cFFJfcpRhXp5ZGfPwK+9G9IzFm44ZizdpMhZvamMs3gLvULxpgrF4k/li8abcxeJNjIvFm74WivdMX4vFm74Wizd9LRZv+los3gLvULzpa7F409di8aavxeJNX4vFm74WiXcd6GuxeNPXYvGmr8XiTV+LxVvgHYo3fS0Wb/paLN70tVi86WuxeNPXQvEe6WuxeNPXYvGmr8XiTV+LxVvgHYo3fS0Wb/paLN70tVi86WuxeNPXQvFO9LVYvOlrsXjT12Lxpq/F4i3wDsWbvhaLN30tFm/6Wize9LVYvOlroXhn+los3vS1WLzpa7F409di8RZ4h+JNX4vFm74Wizd9LRZv+los3vS1ULyFvhaLN30tFm/6Wize9DVnvPP65fDlAuaGt8A7FG/6Wize9LVYvOlrsXjT12Lxpq+F4l3oa7F409di8aavxeJNX4vFW+Adijd9LRZv+los3vS1WLzpa7F409dC8a70tVi86WuxeNPXYvGmr8XiLfAOxZu+Fos3fS0Wb/paLN70tVi86WuheE/0tVi86WuxeNPXYvGmr8XiLfAOxZu+Fos3fS0Wb/paLN70tVi86WuheDf6Wize9LVYvOlrsXjT12LxFniH4k1fi8WbvhaLN30tFm/6Wize9LVQvGf6Wize9LVYvOlrsXjT12LxFniH4k1fi8WbvhaLN30tFm/6Wize9LVIvKeBvhaLN30tFm/6Wize9LVYvAXeoXjT12Lxpq/F4k1f88W7Dnn4cWwd5nTDm74Wizd9LRTvkb4Wizd9LRZv+los3vS1WLwF3qF409di8aavxeJNX4vFm74Wizd9LRTvRF+LxZu+Fos3fS0Wb/paLN4C71C86WuxeNPXYvGmr8XiTV+LxZu+Fop3pq/F4k1fi8WbvhaLN30tFm+Bdyje9LVYvOlrsXjT12Lxpq/F4k1fC8Vb6GuxeNPXYvGmr8XiTV+LxVvgHYo3fS0Wb/paLN70tVi86WvOeOdhoVFzzje86WuheBf6Wize9LVYvOlrsXjT12LxFniH4k1fi8WbvhaLN30tFm/6Wize9LVQvCt9LRZv+los3vS1WLzpa7F4C7xD8aavxeJNX4vFm74Wizd9LRZv+loo3hN9LRZv+los3vS1WLzpa7F4C7xD8aavxeJNX4vFm74Wizd9LRZv+loo3o2+Fos3fS0Wb/paLN70tVi8Bd6heNPXYvGmr8XiTV+LxZu+Fos3fS0U75m+Fos3fS0Wb/paLN70tVi8Bd6heNPXYvGmr8XiTV+LxZu+Fos3fS0S7zbQ12Lxpq/F4k1fi8WbvhaLt8DbF+9aZeFd53LDm74Wizd9LRZv+poz3tMwL7ynPN8/uKWyyNHSFY7tg+uyZO3nQ797RLfDox4e0QPxqINHI50Rj3p4RL/Eox4e0UXxqIdH9FY86uGR4BEedfCIPoxHPTyiO+NRD4/o2XjUwyN6Nh718IiejUcdPEr0bDzq4RE9G496eETPxqMeHtGz8aiHR4JHeNTBI3o2HvXwiJ6NRz08omfjUQ+P6Nl41MMjejYedfAo07PxqIdH9Gw86uERPRuPenhEz8ajHh4JHuFRB4/o2XjUwyN6Nh718IiejUc9PKJn41EPj+jZeNTBI6Fn41EPj+jZeNTDI3o2HvXwiJ6NRz08EjzCow4e0bPxqIdH9Gw86uERPRuPenhEz8ajHh7Rs/Gog0eFno1HPTyiZ+NRD4/o2XjUwyN6Nh718EjwCI86eETPxqMeHtGz8aiHR/RsPOrhET0bj3p4RM/Gow4eVXo2HvXwiJ6NRz08omfjUQ+P6Nl41MMjwSM86uARPRuPenhEz8ajHh7Rs/Goh0f0bDzq4RE9G486eDTRs/Goh0f0bDzq4RE9G496eETPxqMeHgke4VEHj+jZeNTDI3o2HvXwiJ6NRz08omfjUQ+P6Nl41MGjRs/Gox4e0bPxqIdH9Gw86uERPRuPengkeIRHHTyiZ+NRD4/o2XjUwyN6Nh718IiejUc9PKJn41EHj2Z6Nh718IiejUc9PKJn41EPj+jZeNTDI8EjPOrgET0bj3p4RM/Gox4e0bPxqIdH9Gw86uERPRuPXvdoHujZeNTDI3o2HvXwiJ6NRz08omfjUQ+PBI/wqINH9Gw86uERPRuPenhEz8ajHh7Rs/Goh0f0bDzq4NFIz8ajHh7Rs/Goh0f0bDzq4RE9G496eCR4hEcdPKJn41EPj+jZoT3KZfWo1Rs5iNTIsSsH5Rk5duUgJyPHnhyJRowcu3IQfpFjVw5qLnLsykGiRY5dOQQ5kGNPDmIqcuzKQSGNLEeeloObjHL/4Mua5XXN2ucjp60nJ2NZnp2MU74++Lt2tFe0O0E7qi7anaAdvRjtvl67TIlGuxO0o3Gj3QnaUc/R7gTt6PJod4J2gnZo9/XasZeAdidoxy4F2p2gHbsUaHeCduxSoN0J2rFLgXZfr52wS4F2J2jHLgXanaAduxRod4J27FKg3QnaCdqh3ddrxy4F2p2gHbsUaHeCduxSoN0J2rFLgXYnaMcuBdp9vXaFXQq0O0E7dinQ7gTt2KVAuxO0Y5cC7U7QTtAO7b5eO3Yp0O4E7dilQLsTtGOXAu1O0I5dCrQ7QTt2KdDu67Wr7FKg3QnasUuBdidoxy4F2p2gHbsUaHeCdoJ2aPf12rFLgXYnaMcuBdqdoB27FGh3gnbsUqDdCdqxS4F2X6/dxC4F2p2gHbsUaHeCduxSoN0J2rFLgXYnaCdoh3Zfrx27FGh3gnbsUqDdCdqxS4F2J2jHLgXanaAduxRo9/XaNXYp0O4E7dilQLsTtGOX4qF2Uxl+HDu1cl+7PMvC8bIq5QGavIonud2ioeSrRSOg0YqGIqwWDdVULRrKolo01De1aChUWtHMVBy1aCgdatFQA9SioQaoRSOg0YqGGqAWDTVALRpqgFo01AC1aKgBStFc1p0coJcNPUAvG4KAXjYUAb1sBDZq2dAE9LIhCuhlQxXQy4YsoJcNXUAtm5EuoJcNXUAvG7qAXjZ0Ab1sBDZq2dAF9LKhC+hlQxfQy4YuoJcNXUAtm0QX0MuGLqCXDV1ALxu6gF42Ahu1bOgCetnQBfSyoQvoZUMX0MuGLqCWTaYL6GVDF3jMZl4uueXxms3HCgad3se6GJvHa2Vf/AzKIuuh7fPQ7c+gzNPY1qWon+uW5AeaoMO7BjRN1h+wtoVGQKMVTdDR3QKaoJO7BTRBB3cLaILO7RbQBB3bDaCRoFO7BTRBh3YLaKgBPdHUYVmK+vAbKVpdjm3t87mNl+j1QYYYcBaZucqPY+frH7BvOfKfb62bIjAPx5x8EY85XSQec4JLPOaUnHjMSUThmBfaUzzmRK14zKll8ZjT4eIxF5iHY06Hi8ecDhePOR0uHnM6XDzmdLhwzCsdLh5zOlw85nS4eMzpcPGYC8zDMafDxWNOh4vHnA4XjzkdLh5zOlw45hMdLh5zOlw85nS4eMzpcPGYC8zDMafDxWNOh4vHnA4XjzkdLh5zOlw45o0OF485HS4eczpcPOZ0uHjMBebhmNPh4jGnw8VjToeLx5wOF485HS4c85kOF485HS4eczpcPOZ0uLOYXxZrXC+41AfUi9S8XkWr96lfoK+rXK8V2brmC6f1ez3zKNcHfygiKIIi9xWh8qHIA0WIgijyQBEaYnhFPq8ji0y3ipAcUeSBIhRKFFm/nDDL1bcTbh6c5ml55DS3+cHBIsugnqRO9w/+fH5y/bgfk/dFQjzFUwOeUoLx9H2etuWRUxnmlzylXuOpBU8p7nj6Nk+ntKxcmqo8OHjIC5I0lPyS1ILUSO1NanY1kFqJ1LWtUs/jS1KzD4PU7qRm5wipn5A6D+NyGXlIDx455WmVOs/p+uAP+diTQr63ydcx5LIxhqcGPB3ZGMNTC56yMYan7/O024bDyMYYnlrwlI0xPH2bp2Ve/+7XNNwM8aMgH/KdJR8bTch3mnxsCCHfafKxcYN8b5Pvmd3IsbV1OebhdpdnZJcHU22Yyj4PpqowteNr8RKbQkjtTmp2kJDandRsNyG1Eqm7vcA0sTeF1O6kFqRG6mekntdPXrnI81qlSOx5Id9p8rHnhXzvkq/nLMX2GJ5a8JTNMTy14ClbY3j6Pk+7TeaZ3S48teApG1jhPS2SloNLefCGuuc+TOLB++4zG03I9zb5+r1PNLN3hKcWPBU8xVMDnrJzhKfv87Tb+5kzm0x4asFTNpnw9G2ePngDYGbnCPlOk4/tIOQ7Sz5hjwf5TpOPjRvke5t8Pd/NLOzyYKoNU9nnwVQVpnZ8xZwIUiO1N6nZQUJqd1Kz3YTUSqTu9gJTYW8Kqd1JzZ4XUj8h9VlfcCJsj+GpAU8LO2l4+j5Pu73QqrDphqcWPGXLDU/f5ulJeaywO4fU7qQWpEZqHVJ3y2OF3Tmkdic1u3NI/ZTUHT/usrCLhnynycduF/K9S76esxS7XXhqwNPKbheeWvCU3S48fZ+n3Sbzym4XnlrwlA2s0zxtw/K4Y0vjT55+sBHYqGXDdoJeNlRxvWyIxirYjLLBhqaqlw0dUS2biXamlw29SC8bGona+7SJLqCXjcBGLRu6gF42dAG9bOgCetnQBfSyoQuoZdPoAnrZ0AX0sqEL6GVDF9D4upYPNgIbtWzoAnrZ0AX0sqEL6GVDF+jJZlpfLtrG4QGbOswLx6sXi+blVZ2NKqCUzEwT0EqGIqCVDD1AKxlqgFYyAhmlZCgBWsnQAbSSoQJoJUMD0EqGBqCTTBpoAFrJ0AC0kqEBaCVDA9BKRiCjlAwNQCsZGoBWMjQArWRoAFrJ0ACUkhlpAFrJ0AC0kqEBaCVDA9BKRiCjlAwNQCsZGoBWMjQArWRoAFrJ0AB6kmnzcg3zw3fQpLp+K9z8+a0Heethy7AsWsnp/qG5yfrNdO3nx/0OPJEWggGnWAQDTggJBpy+Egy4ADwWcGpQMOBEpmDAaVfBgJPEggGntMUCniltwYBT2oIBp7QFA05pCwZcAB4LOKUtGHBKWzDglLZgwCltwYBT2mIBF0pbMOCUtmDAKW3BgFPaggEXgMcCTmkLBpzSFgw4pS0YcEpbMOCUtljAC6UtGHBKWzDglLZgwCltwYALwGMBp7QFA05pCwac0hYMOKUtGHBKWyzgldIWDDilLRhwSlsw4JS2YMAF4LGAU9qCAae0BQNOaQsGnNIWDDilLRbwidIWDDilLRhwSlsw4JS2YMAF4LGAU9qCAae0BQNOaQsGnNIWDDilLRbwRmkLBpzSFgw4pS0YcEpbMOACcFfAZajzj2Plsvt9/+BxLmlZs7lt2EGWw459O2h42LFvB8EPO/btoA5ix74dpETs2LVjpjtix74dRErs2LeDookd+3aQP7Fj3w7BDuzYtYNWih37dtBKsWPfDlopduzbQSvFjn07aKXYsWdHHmil2LFvB60UO/btoJVix74dtFLs2LdDsAM7du2glWLHvh20UuzYt4NWih37dtBKsWPfDlopduzaMdJKsWPfDlopduzbQSvFjn07aKXYsW+HYAd27NpBK8WOfTtopdixbwet1JcdZZgX4GXMwy1w8mcw4BTNWMATkTIYcLpjMOCkxGDAqYPBgAvAYwGn4QUDTpYLBpzSFgw4pS0YcEpbLOCZ0hYMOKUtGHBKWzDglLZgwAXgsYBT2oIBp7QFA05pCwac0hYMOKUtFnChtAUDTmkLBpzSFgw4pS0YcAF4LOCUtmDAKW3BgFPaggGntAUDTmmLBbxQ2oIBp7QFA05pCwac0hYMuAA8FnBKWzDglLZgwCltwYBT2oIBp7TFAl4pbcGAU9qCAae0BQNOaQsGXAAeCzilLRhwSlsw4JS2YMApbcGAU9piAZ8obcGAU9qCAae0BQNOaQsGXAAeCzilLRhwSlsw4JS2YMApbcGAU9piAW+UtmDAKW3OgOf12+XLBcwtcEpbMOCUtmDABeCxgFPaggGntAUDTmkLBpzSFgw4pS0W8JnSFgw4pS0YcEpbMOCUtmDABeCxgFPaggGntAUDTmkLBpzSFgw4pS0UcBkobcGAU9qCAae0BQNOaQsGXAAeCzilLRhwSlsw4JS2YMApbcGAU9piAR8pbcGAU9qCAae0BQNOaQsGXAAeCzilLRhwSlsw4JS2YMApbcGAU9piAU+UtmDAKW3BgFPaggGntAUDLgCPBZzSFgw4pS0YcEpbMOCUtmDAKW2xgGdKWzDglLZgwCltwYBT2oIBF4DHAk5pCwac0hYMOKUtGHBKWzDglLZYwIXSFgw4pS0YcEpbMOCUtmDABeCxgFPafAGvQ16eWR3mdAuc0hYMOKUtGHBKWzDglLZYwAulLRhwSlsw4JS2YMApbcGAC8BjAae0BQNOaQsGnNIWDDilLRhwSlss4JXSFgw4pS0YcEpbMOCUtmDABeCxgFPaggGntAUDTmkLBpzSFgw4pS0W8InSFgw4pS0YcEpbMOCUtmDABeCxgFPaggGntAUDTmkLBpzSFgw4pS0W8EZpCwac0hYMOKUtGHBKWzDgAvBYwCltwYBT2pwBz8NCo+acb4FT2oIBp7QFA05piwV8prQFA05pCwac0hYMOKUtGHABeCzglLZgwCltwYBT2oIBp7QFA05pCwW8DJS2YMApbcGAU9qCAae0BQMuAI8FnNIWDDilLRhwSlsw4JS2YMApbbGAj5S2YMApbcGAU9qCAae0BQMuAI8FnNIWDDilLRhwSlsw4JS2YMApbbGAJ0pbMOCUtmDAKW3BgFPaggEXgMcCTmkLBpzSFgw4pS0YcEpbMOCUtljAM6UtGHBKWzDglLZgwCltwYALwGMBp7QFA05pCwac0hYMOKUtGHBKWyzgQmkLBpzSFgw4pc0Z8FplAV7ncguc0hYMuAA8FnBKmzPg0zAvwKc83z+4pbLY0dIVju2Da1qO/fnQD5EoeIjURSTKICJ1EYniiEhdRKJkIlIPkQqFFJG6iER5RaQuIlF0EamLSJRiROoikiASIvUQibKNSF1EomwjUheRKNuI1EUkyjYidRGJso1IPUSqlG1E6iISZRuRuohE2UakLiJRthGpi0iCSIjUQyTKNiJ1EYmyjUhdRKJsI1IXkSjbiNRFJMo2IvUQaaJsI1IXkSjbiNRFJMo2InURibKNSF1EEkRCpB4iUbYRqYtIlG1E6iISZRuRuohE2UakLiJRthGph0iNso1IXUSibCNSF5Eo24jURSTKNiJ1EUkQCZF6iETZRqQuIlG2EamLSJRtROoiEmUbkbqIRNlGpB4izZRtROoiEmUbkbqIRNlGpC4iUbYRqYtIgkiI1EMkyjYidRGJso1IXUSibCNSF5Eo24jURSTKNiJ1EKkOlG1E6iISZRuRuohE2UakLiJRthGpi0iCSIjUQyTKNiJ1EYmyjUhdRKJsI1IXkSjbiNRFJMo2IvUQaaRsI1IXkSjbiNRFJMo2InURibKNSF1EEkRCpB4iUbYRqYtIlG1E6iISZRuRuohE2UakLiJRthGph0iJso1IXUSibCNSF5Eo24jURSTKNiJ1EUkQCZF6iETZRqQuIlG2EamLSJRtROoiEmUbkbqIRNlGpB4iZco2InURibKNSF1EomwjUheRKNuI1EUkQSRE6iESZRuRuohE2UakLiJRthGpi0iUbUTqIhJlG5F6iCSUbUTqIhJlG5G6iETZRqQuIlG2EamLSIJIiNRDJMo2InURibKNSF1EomwjUheRKNuI1EUkyjYi9RCpULYRqYtIlG1E6iISZRuRuohE2UakLiIJIkUWKZdVpFZv7SBXR7YjT8vBTUa5f3AepuXJ5aF9PnLaenIyluXZyTjl64M/vKNu490Z3hHD8e4M72jneHeGd6R2vDvBu0qZx7szvCPk490Z3tH98e4M79gmwLszvBO8w7sTvGO/Au/O8I79Crw7wzv2K/DuDO/Yr8C7M7xjvwLvTvBuYr8C787wjv0KvDvDO/Yr8O4M79ivwLszvBO8w7sTvGO/Au/O8I79Crw7wzv2K/DuDO/Yr8C7M7xjvwLvTvCusV+Bd2d4x34F3p3hHfsVeHeGd+xX4N0Z3gne4d0J3rFfgXdneMd+Bd6d4R37FXh3hnfsV+DdGd6xX4F3J3g3s1+Bd2d4x34F3p3hHfsVeHeGd+xX4N0Z3gne4d0J3rFfgXdneMd+Bd6d4R37FXh3hnfsV+DdGd6xX4F3X+/dNLBfgXdneMd+Bd6d4R37FXh3hnfsV+DdGd4J3uHdCd6xX4F3Z3jHfgXeneEd+xV4d4Z37Ffg3RnesV+Bdyd4N7JfgXdneMd+xUPvprIcO10fuslmlgXkZVXKAzZ5NU9y22BD09fLhu6tl43ARi0b+qleNjRGvWzocHrZ0Kr0sqHnqGWTaB562dAF9LKhC+hlQxfQy0Zgo5YNXUAvG7qAXjZ0Ab1s6AJ62dAF1LLJdAG9bOgCetnQBfSyoQvoZSOwUcuGLqCXDV1ALxu6gF42dAG9bOgCatkIXUAvG7qAXjZ0Ab1s6AJ62Qhs1LKhC+hlQxfQy4YuoJcNXUAvG7qAWjaFLqCXDV1ALxu6gF42dAG9bAQ2atnQBfSyoQvoZUMX0MuGLqCXDV1ALZtKF3jMZl4uueXxms3HCgad3lNerjmneby/gmVcP5XyegW3hJ3Wj4+cxvFqJerbfxKCTvruOAatAu44ChxdcAxaG9xxDFom3HEMWjHccQxaPNxxDFpHvHGcgpYUdxzpOT440nN8cKTn+OAocHTBkZ7jgyM9xwdHeo4PjvQcHxzpOS44NnqOD470HB8c6Tk+ONJzfHAUOLrgSM/xwZGe44MjPccHR3qOD470HBccZ3qOD470HB8c6Tk+ONJzfHAUOLrgSM/xwZGe44MjPccHR3qOD470HA8c20DP8cGRnuODIz3HB0d6jg+OAkcXHOk5PjjSc3xwpOf44EjP8cGRnuOC40jP8cGRnuODIz3HB0d6jg+OAkcXHOk5PjjSc3xwpOf44EjP8cGRnuOCY6Ln+OBIz/HBkZ7jgyM9xwdHgaMLjvQcHxzpOT440nN8cKTn+OBIz3HBMdNzfHCk5/jgSM/xwZGe44OjwNEFR3qOD470HB8c6Tk+ONJzfHCk57jgKPQcHxzpOT440nN8cKTn+OAocHTBkZ7jgyM9xwdHeo4PjvQcHxzpOS44FnqOD470HB8c6Tk+ONJzfHAUOLrgSM/xwZGe44MjPccHR3qOD470HBccKz3HB0d6jg+O9BwfHOk5PjgKHF1wpOf44EjP8cGRnuODIz3HB0d6jguOEz3HB0d6jg+O9BwfHOk5PjgKHF1wpOf44EjP8cGRnuODIz3HB0d6jguOjZ7jgyM9xwdHeo4PjvQcHxwFji440nN8cKTn+OBIz/HBkZ7jgyM9xwXHmZ7jgyM9xwdHeo4PjvQcHxwFji440nN8cKTn+OBIz/HBkZ7jgyM9xwPHeaDn+OBIz/HBkZ7jgyM9xwdHgaMLjvQcHxzpOT440nN8cKTn5HG4z3Eel6uYS7vPsciKvH0+6jhscpzGti5F/Vy3JD/QkGhOQ9MkLdfQNtCMVBe1aAgpatHQRtSiIXeoRSOg0YqGKKEWDZ1BLRrSgVo01ICeaOqwPGzN5QGaVpdjW/t8buMl2XyQIQacRWausjzs9Q/Yt5j2z7e2uURliMecfBGPOV0kHnOCSzzmAvNwzElE8ZjTnuIxJ2rFY04ti8ecDheOeabDxWNOh4vHnA4XjzkdLh5zgXk45nS4eMzpcPGY0+HiMafDxWNOhwvHXOhw8ZjT4eIxp8PFY06Hi8dcYB6OOR0uHnM6XDzmdLh4zOlw8ZjT4cIxL3S4eMzpcPGY0+HiMafDxWMuMA/HnA4XjzkdLh5zOlw85nS4eMzpcOGYVzpcPOZ0uHjM6XDxmNPh4jEXmIdjToeLx5wOF485HS4eczpcPOZ0uLOYXxZrXC+41AfUi9Tl6RVp9T71C/R1leu1ImXr4Dy0z7WQ64O/KzKR7VDkgSJUPhR5oAhREEUeKEJDDK/I53VkkelWEUERFLmvCIUSRdYvJ8xy9e2EmweneVoeOc1tfnCwyDKoJ6nT/YM/n59cP+6PyXuiquKpBU8pwXj6Pk/b8sipDPNLnlKv8dSCpxR3PH2bp1NatnvSVOXBwUMeloOHkl+RurFHgNTupGZXA6mVSF3bKvU8viQ1+zBI7U5qdo6Q+gmp8zAul5GH9OCRU55WqfOcrg/+kE+QD/neJV+/kNvYGMNTC56yMYanFjxlYwxP3+dptw2HxsYYnlrwlI0xPH2bp2Ve/+7XNNwM8TMbWMh3mnxsNCHfafKxIYR8p8nHxg3yvU2+Z3Yjx9bW5ZiH212eWTAVU02Yyj4PpqowteNr8WY2hZDandTsICG1O6nZbkJqJVJ3e4HpzN4UUvuSOg0De15I/ZTU8/rJK2N6qVJc5GPPC/lOk489L+R7l3zdZqmLp2yP4akFTwVP8dSAp2yN4en7PO03mbPbhacWPGUDK7ynRdJycCkP3lD33IdJ3H3f/UU+NpqQ723y9Xqf6MVT9o7w1ICnI9tBeGrBU3aO8PR9nnZ6P/PFUzaZ8NSCp2wy4enbPL37BsCLfIJ8yHeWfGwHId9p8rHHg3ynycfGDfK9Tb5+72a+mMouD6baMJV9HkxVYWrHV8wlNoWQ2p3U7CAhtTup2W5CaiVSd3uBaWJvCqndSS1IjdR/XOpzvuDk4inbY3hqwVN20vD0fZ52e6FVYtMNTy14ypYbnr7N07PyGLtzSO1N6szuHFIrkbpbHsvsziG1O6nZnUPqp6Tu+HGXmV005DtNPkE+5HuTfD1nKXa78NSCp+x24akFT9ntwtP3edpvMme3C08teMoG1mmetmGJhmNL40+efmcj7MPoZcN2gl42VHG9bIjGKtiMssFGYKOWDR1RLxvamV429CK9bGgkeu/T6AJq2RS6gF42dAG9bOgCetnQBfSyEdioZUMX0MuGLqCXDV1ALxu6gF42dAGNr2v5zqbSBfSyoQvoZUMX0MuGLqCXjcCmI5tpfblou3rUbTZ1mBeOVy8WzcurOitVQCsZmoBWMhQBrWToAVrJUAOUkploAVrJUAK0kqEDaCVDBdBKRiCjlAwNQCsZGoBWMjQArWRoAFrJ0ACUkmk0AK1kaABaydAAtJKhAWglI5BRSoYGoJUMDUArGRqAVjI0AK1kaABKycw0AK1kaABaydAAtJKhAWglI5BRSoYG0JNMm5drmB++gybV9Vvh5s9vPchbn9JdhmXRSk73D81N1m+maz8/7gdw0kIw4BSLYMAJIcGA01dCAb/QBHgs4NSgYMCJTMGA066CAReAxwJOaQsGnNIWDDilLRhwSlsw4JS2WMBHSlsw4JS2YMApbcGAU9qCAReAxwJOaQsGnNIWDDilLRhwSlsw4JS2WMATpS0YcEpbMOCUtmDAKW3BgAvAYwGntAUDTmkLBpzSFgw4pS0YcEpbLOCZ0hYMOKUtGHBKWzDglLZgwAXgsYBT2oIBp7QFA05pCwac0hYMOKUtFnChtAUDTmkLBpzSFgw4pS0YcAF4LOCUtmDAKW3BgFPaggGntAUDTmmLBbxQ2oIBp7QFA05pCwac0hYMuAA8FnBKWzDglLZgwCltwYBT2oIBp7TFAl4pbb6Ay1DnH8fKmOr9g8e5pGXN5rZhB1kOO/btoOFhx74dBD/s2LdDsAM7du0gJWLHvh10R+zYt4NIiR37dlA0sWPfDvInduzaMdFKsWPfDlopduzbQSvFjn07aKXYsW+HYAd27NpBK8WOfTtopdixbwetFDv27aCVYse+HbRS7Ni1o9FKsWPfDlopduzbQSvFjn07aKXYsW+HYAd27NpBK8WOfTtopdixbwetFDv27aCVYse+HbRS7Ni1Y6aVYse+HbRS7Ni3g1aKHft20Ep92VGGeQFexjzcAheAxwJO0QwGnEgZDDjdMRhwUmIw4NTBUMDTQPALBpyGFww4WS4YcEpbMOAC8FjAKW3BgFPaggGntAUDTmkLBpzSFgv4SGkLBpzSFgw4pS0YcEpbMOAC8FjAKW3BgFPaggGntAUDTmkLBpzSFgt4orQFA05pCwac0hYMOKUtGHABeCzglLZgwCltwYBT2oIBp7QFA05piwU8U9qCAae0BQNOaQsGnNIWDLgAPBZwSlsw4JS2YMApbcGAU9qCAae0xQIulLZgwCltwYBT2oIBp7QFAy4AjwWc0hYMOKUtGHBKWzDglLZgwCltsYAXSlsw4JS2YMApbcGAU9qCAReAxwJOaQsGnNIWDDilzRnwvH67fLmAuQVOaQsGnNIWC3iltAUDTmkLBpzSFgw4pS0YcAF4LOCUtmDAKW3BgFPaggGntAUDTmmLBXyitAUDTmkLBpzSFgw4pS0YcAF4LOCUthwLOKUtGHBKWzDglLZgwCltsYA3Slsw4JS2YMApbcGAU9qCAReAxwJOaQsGnNIWDDilLRhwSlsw4JS2WMBnSlsw4JS2YMApbcGAU9qCAReAxwJOaQsGnNIWDDilLRhwSlsw4JS2UMDzQGkLBpzSFgw4pS0YcEpbMOAC8FjAKW3BgFPaggGntAUDTmkLBpzSFgv4SGkLBpzSFgw4pS0YcEpbMOAC8FjAKW3BgFPaggGntAUDTmkLBpzSFgt4orQFA05p8wW8Dnn4cWwd5nQLnNIWDDilLRhwAXgs4JS2YMApbcGAU9qCAae0BQNOaYsFPFPaggGntAUDTmkLBpzSFgy4ADwWcEpbMOCUtmDAKW3BgFPaggGntMUCLpS2YMApbcGAU9qCAae0BQMuAI8FnNIWDDilLRhwSlsw4JS2YMApbbGAF0pbMOCUtmDAKW3BgFPaggEXgMcCTmkLBpzSFgw4pS0YcEpbMOCUtljAK6UtGHBKWzDglDZnwPOwPLOac74FTmkLBlwAHgs4pS0YcEpbMOCUtmDAKW3BgFPaYgGfKG3BgFPaggGntAUDTmkLBlwAHgs4pS0YcEpbMOCUtmDAKW3BgFPaYgFvlLZgwCltwYBT2oIBp7QFAy4AjwWc0hYMOKUtGHBKWzDglLZgwCltsYDPlLZgwCltwYBT2oIBp7QFAy4AjwWc0hYMOKUtGHBKWzDglLZgwCltoYDLQGkLBpzSFgw4pS0YcEpbMOAC8FjAKW3BgFPaggGntAUDTmkLBpzSFgv4SGkLBpzSFgw4pS0YcEpbMOAC8FjAKW3BgFPaggGntAUDTmlzBrxWWYDXudwCp7TFAp4obcGAU9qcAZ+GeQE+5fn+wS2VxY6WrnBsH1zTcuzPh36IRMFDpC4iUQYRqYtIgkiI1EMkSiYidRGJQopIXUSivCJSF5EouojURSRKMSL1EClToBGpi0iUbUTqIhJlG5G6iETZRqQuIgkiIVIPkSjbiNRFJMo2InURibKNSF1EomwjUheRKNuI1EMkoWwjUheRKNuI1EUkyjYidRGJso1IXUQSREKkHiJRthGpi0iUbUTqIhJlG5G6iETZRqQuIlG2EamHSIWyjUhdRKJsI1IXkSjbiNRFJMo2InURSRAJkXqIRNlGpC4iUbYRqYtIlG1E6iISZRuRuohE2UakHiJVyjYidRGJso1IXUSibCNSF5Eo24jURSRBJETqIRJlG5G6iETZRqQuIlG2EamLSJRtROoiEmUbkXqINFG2EamLSJRtROoiEmUbkbqIRNlGpC4iCSIhUg+RKNuI1EUkyjYidRGJso1IXUSibCNSF5Eo24jUQ6RG2UakLiJRthGpi0iUbUTqIhJlG5G6iCSIhEg9RKJsI1IXkSjbiNRFJMo2InURibKNSF1EomwjUg+RZso2InURibKNSF1EomwjUheRKNuI1EUkQSRE6iESZRuRuohE2UakLiJRthGpi0iUbUTqIhJlG5E6iFQGyjYidRGJso1IXUSibCNSF5Eo24jURSRBJETqIRJlG5G6iETZRqQuIlG2EamLSJRtROoiEmUbkXqINFK2EamLSJRtROoiEmUbkbqIRNlGpC4iCSIhUg+RKNuI1EUkyjYidRGJso1IXUSibCNSF5Eo24jUQ6RE2UakLiJRthGpi0iUbUTqIhJlG5G6iCSIhEg9RKJsI1IXkSjbiNRFJMo2InURibKNSF1EomwjUg+RMmU7tEi5rCJ9e0K/2kGujmxHnpaDm4xy/+A8TMuTy0P7fOS09eRkLMuzk3HK1wd/eEfdxrszvCOG490Z3gne4d0J3pHa8e4M7yjzeHeGd4R8vDvDO7o/3p3hHdsEeHeCd8KuAt6d4R37FXh3hnfsV+DdGd6xX4F3Z3gneId3J3jHfgXeneEd+xV4d4Z37Ffg3RnesV+Bd2d4x34F3p3gXWG/Au/O8I79Crw7wzv2K/DuDO/Yr8C7M7wTvMO7E7xjvwLvzvCO/Qq8O8M79ivw7gzv2K/AuzO8Y78C707wrrJfgXdneMd+Bd6d4R37FXh3hnfsV+DdGd4J3uHdCd6xX4F3Z3jHfgXeneEd+xV4d4Z37Ffg3RnesV+Bdyd4N7FfgXdneMd+Bd6d4R37FXh3hnfsV+DdGd4J3uHdCd6xX4F3Z3jHfgXeneEd+xV4d4Z37Ffg3RnesV+Bdyd419ivwLszvGO/Au/O8I79Crw7wzv2K/DuDO8E7/DuBO/Yr8C7M7xjvwLvzvCO/YqH3o2jlHU12k/mfaxh0PYusq6hVLm/hjKXtHg4Pzo45Wn9kczz5w9aKj8WPGh0ft+Ci8iy4FKn6wXfeOS6XLL8/NvnO5s5aJh9I5u2PHIqw/wSm6Dx8n1syrz+3NQ03PyimoNWu/ct+JTWvwzT1cGbPwyXv9XLExzn4fbPyBy0bRmhI9A5j04a8rAcPJT80l+doEnFH8igjUILyNpWkPP4EsigQ78/kEHLQ57SClLKo3ozDutq5Pp5cNt65FmWEHdZl3K94BtPMK/lUHK7bWtz0Exhgk4dgoYKI3SCpgojdIJ2DSN0gnYNI3QEOorpBI0VRugELRBG6ATNCkbo0Ao006EVKKYz0go006EVaKZDK9BMh1agmY5ARzEdWoFmOrQCzXRoBZrp0Ao006EVKKaTaAWa6dAKNNOhFWimQyvQTEego5gOrUAzHVqBZjq0As10aAWa6dAKFNPJtALNdGgFmunQCjTToRVopiPQUUyHVqCZDq1AMx1agWY6tALNdGgFiukIrUAzHVqBZjq0As10aAWa6Qh0FNOhFWimQyvQTIdW8AforJ8+PqYxfSUdWoFmOrQCxXQKrUAzHVqBZjq0As10aAWa6Qh0FNOhFWimQyvQTIdWoJkOrUAzHVqBYjqVVqCZDq1AMx1agWY6tALNdAQ6iunQCjTToRVopkMr0EyHVqCZDq1AMZ2JVqCZDq1AMx1agWY6tALNdAQ6iunQCjTToRVopkMr0EyHVqCZDq1AMZ1GK9BMh1agmQ6tQDMdWoFmOgIdxXRoBZrp0Ao006EVaKZDK9BMh1agmM5MK9BMh1agmQ6tQDMdWoFmOgIdxXRoBZrp0Aoe00mlrHTmL6VDK9BMh1agmQ6tQC+daaAVaKZDK9BMh1agmQ6tQDMdgY5iOrQCzXRoBZrp0Ao006EVaKZDK1BMZ6QVaKZDK9BMh1agmQ6tQDMdgY5iOrQCzXRoBZrp0Ao006EVaKZDK1BMJ9EKNNOhFWimQyvQTIdWoJmOQEcxHVqBZjq0As10aAWa6dAKNNOhFSimk2kFmunQCjTToRVopkMr0ExHoKOYDq1AMx1agWY6tALNdGgFmunQChTTEVqBZjq0As10aAWa6dAKNNMR6CimQyt4TCfn9Qnm9oBOq8uxrX1e8XhZ+o/1Zvrvu95zlR/Hzm34ab3f/ZNDKfBCkqrghSQFwgnJQq3wQpKy4YUkFcQLSYqJF5ICSSckKTFeSNJ4vJCk8XghSePxQpLG44RkpfF4IUnj8UKSxuOFJI3HC0mBpBOSNB4vJGk8XkjSeLyQpPF4IUnjcUJyovF4IUnj8UKSxuOFJI3HC0mBpBOSNB4vJGk8XkjSeLyQpPF4IUnjcUKy0Xi8kKTxeCFJ4/FCksbjhaRA0glJGo8XkjQeLyRpPF5I0ni8kKTxOCE503i8kKTxeCFJ4/FCksbjhaRA0glJGo8XkjSeviQvSzCul1HqA5ZF6nLRRVq9z/KCcl27eg2+bD7DYUGY8yjXB3+AJwkFBU9BCgqe4BQSfBvoU07Bf17H5RlOt+DJWUHBU7+8gl+/QifL1XfobB6c5ml55DS3+cHBIssImqRO9w/+fH5y/bj1h30UO+w7zz7BPux70r62PHIqw/ySfZRR7DvPPmou9j1p35SWDYJvn6b44OAhD8vBQ8kvqUp/RlUjqlLMUfWtqta2qjqPL6lK40dVG6qO7Eqg6r/lYVwuIw/pwSOnPK2q5quvgl+y98h+B0o9qVS/8Diy6YJ959nHpgv2nWefYB/2PWlft+w9sumCfefZx6YL9j1pX5nXv7w1DbeDLJsjKNVZKTYxUKqzUmw2oFRfpRKbAij1pFLP7F+Nra3LMQ+3OwiJHQT8O9M/9hDw743+dXxVVGLDAVWNqCqoiqo2VGUrA1Xfqmq3F/Al9j1Q1Yiq7Keg6sXPef3UhDG9Oqmzn4JSnZViPwWlnlOq4+SR2XrBvvPsY+MF+86zj20X7HvWvm7TaWYnBfvOs0+wz6d9RdZnWMqDt/c895bxB+/DzWxioNRpHwCY2ZfAvvPsY6sB+86zj10J7Dvt4yczGxjYd5p9wgYG9j1p34O3Iwm7EijVWSm2GlCqs1LsH6BUZ6UEpVDqfZ8j++ilcMIOAv6d6R97CPhn49sJhA0HVDWiKrsTqGpEVbYyUNXGF2kU9j1Q1Yiq7Keg6mkfUl/YesG+8+xjlwb7TvuQ+iLYh32n2cd2DvbZ+AC2ws4PqhpRlZ0fVLXxAWyFnR9UNaIqOz+o2veD3So7NCjVWSl2UlDqtM/LquykYN959rGTgn3n2SfYh31nfVpbZScF+86zj82Rzva1YYlcY0vjT/Z9rDiN/6tXnFT91StOcf3iFZ8Ikm9c8VE2Vpxe99UrTqP66hWny3z1igsr/sUrzvz91fcqzJxfveLMnF+94sycX73izJxfvOKNmfOrV5yZ86tXnJnzq1ecmfOrV1xY8S9ecWbOr15xZs6v22X/WHFmzq9ecWbOr15xZs4vXvGZmfOrV5yZ8/GK17Rc81hLuV7xjzVkinx9DZkLX19DYQ1fXkNmt9fXkGns9TVkvnp9DZmYXl9DZqBX13AemGpeX0PmlNfXkDnl9TVkTnl9DYU1fHkNmVNeX0PmlNfXkDnl9TVkTnl9DZlTXl7DkTnl9TVkTnl9DZlTXl9D5pTX11BYw5fXkDnl9TVkTnl9DZlTXl9D5pTX15A55eU1TMwpr68hc8rra8ic8ngNp/Uz1cb56kuJtl+tOKTP5Rjy9XcYffsut63VWx9cxs9XN+bN5zgOsnK5+kjJy8EfNJmYPNEUaDqiyRTZm2bO+ZOmTI9otvU5jq0NL9JknvVEk8naE01m/OdoXr0ddZNmnmVeHnm+/lDhrU8gllyXN7pKbvn64A861APFdDJdQjMdiodmOrQUzXRoI5rpCHQU06FdaKZDi9BMh7agmQ6tQDMdWoFiOkIr0EyHVqCZDq1AMx1agWY6Ah3FdGgFmunQCjTToRVopkMr0EyHVqCYTqEVaKZDK9BMh1agmQ6tQDMdgY5iOrQCzXRoBZrp0Ao006EVaKZDK1BMp9IKNNOhFWimQyvQTIdWoJmOQEcxHVqBZjq0As10aAWa6dAKNNOhFSimM9EKNNOhFWimQyvQTIdWoJmOQEcxHVqBZjq0As10aAUP6aRxXC4jXR76ms7HGjLRv76GQefuKeX1Mh6tYavL82vt8yLGy0/19yVsQYfjZ5bwsuvz49j56nNHvy3hm3/PtqCzsQ04QUdjG3CCTsY24Ahw9MIJOhfbgBN0LLYBJ+hUbANO0HHbBhzmeL1wZgqBYjgUAsVwKASK4VAIFMMR4OiFQyFQDIdCoBgOhUAxHAqBYjgUAq1w8jBQCBTDoRAohkMhUAyHQqAYjgBHLxwKgWI4FALFcCgEiuFQCBTDoRDohTNSCBTDoRAohkMhUAyHQqAYjgBHLxwKgWI4FALFcCgEiuFQCBTDoRDohZMoBIrhUAgUw6EQKIZDIVAMR4CjFw6FQDEcCoFiOBQCxXAoBIrhUAj0wskUgodwLs9qXB+51Ad4itTloYu0eh/Phc66HPWaZdk6OA8LlZxHuT74gyVBwQ9L+oMfluQKPywFlmZYfl5HFpluWRJD/LCknRhiuX56eparj0/fPPjb9yL8OPjbR9o9OFhkmaOS1On+wZ/PT64fdxmM6D0I1VUoGhVCXSxqyyOnMswvCUVXQ6ieQgktEKH+LU1pKcZpqvLg4EtAXg4eSn7JPuol9p1nH70V+561r7bVvnl8yT4KMfadZ59gn0v7vr2Xdjl4SA8eOeVptS/P6frgD0uo5VjSM4gJyR6hugpFskeorkKR7BGqa2El2SNUT6EKyR6hLv+f8/onr6bhZnQrpHUseWwJCRxLHltCqsaSx5YIlmDJUxsaY2vrcszDbX8u9GeU6qwUBRqlTnvJSSFXY9959tG2se88+wjh2HfaC54q1Rz7zrOPGu/Vvnl9j/KYXpxNKzUeSx5bQo3Hkp435lUQCqF6CkW2R6iuQhHtEarrPEaHR6iuQpHW7QhVJC0Hl/Lg3QLPvZvzwfvpKgkcS3q+W2WiaiNUV6EI1QjVVSiaNkL1fPvTRP5GqK5CCUIh1KN3N0w0bSx5bAmhGkseW0J9xpLHlpCUsaTvm58m+jNK9VWqUaBR6rT3lDRyNfadZx9tG/vOs48Qjn2nvaOpCfZh32n2UeN92nfWx/42wj1CdRWKxo9QPV+m0NgOQKiuQrEZgFCn1YuZfQPsO88+9g2w77R6MbNvgH3n2ce+gVf7On7K0CxYgiUPLaHDY0nXG3M6PEJ1FYoOj1BdhaLDI1TXeYwOj1AdhbrYglAPhWrDEl/GlsafhPpYRApxh0UkdHZYRHpdh0UUFvGpRRxlYxGpPR0WkcLRYRGZ6jssIpNsh0Vkenv9r/PIxNJhEZlYOiwiE0uHRWRi6bCIwiK+vohMLB0WkYmlwyIysXRYRCaWDovIxPL6IiYmlpc27T4WkYmlwyIysXRYRCaWDosoLOLrixh0YmnD+sKKNk7Xi/ixLEFnkEfLEnSqeLQsQeeER8sS9M7/wbLkoPfyj5Yl6N35o2UJer/9aFmC3kE/WhZhWbaWhbvczWXhLndzWbjL3VwW7nI3l4W73K1lEe5yN5eFu9zNZeEud3NZuMvdXBZhWbaWhbvczWXhLndzWbjL3VwW7nI3l4W73K1lKdzlbi4Ld7mby8Jd7uaycJe7uSzCsmwtC3e5m8vi5y5X5uXDcy6/MYf7B89l/nHsfP0pFt++TOHm2FTXD8CcPz+TJ2994kUZlidXcrp/aKrz5+dqXr0eJ5cfYPzcZzsD4+dO3xaYPAzrB9UMpd0/eJzL8ntvnFu+pehnMAlMsfqZoyJT9DP2RaboZ0qNTNHPUB2ZokDRAUU/ySIyRQqLB4rkGA8UaTceKNJuHFCcaDceKNJuPFCk3XigSLvxQFGg6IAi7cYDRdqNB4q0Gw8UaTceKNJuHFBstBsPFGk3HijSbjxQpN14oChQdECRduOBIu3GA0XajQeKtBsPFGk3DijOtBsPFGk3HijSbjxQpN14oChQdECRduOBIu3GA0XajQeKtBsPFGk39immgXbjgSLtxgNF2o0HirQbDxQFig4o0m48UKTdeKBIu/FAkXbjgSLtxgHFkXbjgSLtxgNF2o0HirQbDxQFig4o0m48UKTdeKBIu/FAkXbjgSLtxgHFRLvxQJF244Ei7eYkipelWhZC2ngLhhxzDpgH31iakgBGJxiiiVIwdBClYEgbSsFQK5SCIUDoBJNpCkrBkAmUgmHyVwqGyV8pGAGMTjBM/krBMPkrBcPkrxQMk79SMEz+OsEIk79SMEz+SsEw+SsFw+SvFIwARicYJn+lYJj8lYJh8lcKhslfKRgmf51gCpO/UjBM/krBMPkrBcPkrxSMAEYnGCZ/pWCY/JWCYfJXCobJXykYJn+dYCqTv1IwTP5KwTD5KwXD5K8UjABGJxgmf6VgmPyVgmHyVwqGyV8pGCZ/nWAmJn+lYJj8lYJh8lcKhslfKRgBjE4wTP5KwTD5KwXD5K8UDJO/UjBM/jrBNCZ/pWCY/JWCYfJXCobJXykYAYxOMEz+SsEw+SsFw+SvFAyT/zlgun5vViMTOKA40xQ8UCRAeKBIrfBAkbThgaJA0QFFookHihQWDxTJMR4o0m48UKTd2Kd4eSwoOqBIu/FAkXbjgSLtxgNFgaIDirQbDxRpNx4o0m48UKTdeKBIu3FAcaTdeKBIu/FAkXbjgSLtxgNFgaIDirQbDxRpNx4o0m48UKTdeKBIu3FAMdFuPFCk3XigSLvxQJF244GiQNEBRdqNB4q0Gw8UaTceKNJuPFCk3TigmGk3HijSbjxQpN14oEi78UBRoOiAIu3GA0XajQeKtBsPFGk3HijSbhxQFNqNB4q0Gw8UaTceKNJuPFAUKDqgSLvxQJF244Ei7cYDRdqNB4q0GwcUC+3GA0XajQeKtJuTKErJy0LINN0/uNUFYpvaLUPKjX2GAkPzDKk29hnSbOwzpNjYZ0ivsc+QWmOeYaXV2GdIqbHPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TT2GdIpzHPcKLT2GdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TT2GdIpzHPsNFp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk05hnONNp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk01hnKAOdxj5DOo19hnQa+wzpNPYZCgzNM6TT2GdIp7HPkE5jnyGdxj5DOo15hiOdxj5DOo19hnQa+wzpNPYZCgzNM6TT2GdIp7HPkE5jnyGdxj5DOo15holOY58hncY+QzqNfYZ0GvsMBYbmGdJp7DOk09hnSKexz5BOY58hncY8w0ynsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOeodBp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk05hnWOg09hnSaewzpNPYZ0insc9QYGieIZ3GPkM6jX2GdBr7DOk09hnSacwzrHQa+wzpNPYZ0mnsM6TT2GcoMDTPkE5jnyGdxj5DOo19hnQa+wzpNOYZTnQa+wzpNPYZ0mnsM6TT2GcoMDTPkE5jnyGdxj5DOo19hnQa+wzpNOYZNjqNfYZ0GvsM6TT2GdJp7DMUGJpnSKexz5BOY58hncY+QzqNfYZ0GvMMZzqNfYZ0GvsM6TT2GdJp7DMUGJpnSKexz5BOY58hncY+QzqNfYZ0GusMy0Cnsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOe4Uinsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOeYaLT2GdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TTnMUwy8qwjbdgiC/ngEl1Xh92knIDJlNUlIIhkygFQ/tQCoagoRSMAEYnGNKDUjD0BKVgiARKwTD5KwXD5K8TjDD5KwXD5K8UDJO/UjBM/krBCGB0gmHyVwqGyV8pGCZ/pWCY/JWCYfLXCaYw+SsFw+SvFAyTv1IwTP5KwQhgdIJh8lcKhslfKRgmf6VgmPyVgmHy1wmmMvkrBcPkrxQMk79SMEz+SsEIYHSCYfJXCobJXykYJn+lYJj8lYJh8tcJZmLyVwqGyV8pGCZ/pWCY/JWCEcDoBMPkrxQMk79SMEz+SsEw+SsFw+SvE0xj8lcKhslfKRgmf6VgmPyVghHA6ATD5K8UDJO/UjBM/krBMPkrBcPkrxPMzOSvFAyTv1IwTP5KwTD5KwUjgNEJhsn/HDB5GJbnlofS7h88zmX5PrNxbvmWIpnAA0WaggeKBAgPFKkV9inWgbThgSIdxANFookHihQWDxQFig4o0m48UKTdeKBIu/FAkXbjgSLtxgHFkXbjgSLtxgNF2o0HirQbDxQFig4o0m48UKTdeKBIu/FAkXbjgSLtxgHFRLvxQJF244Ei7cYDRdqNB4oCRQcUaTceKNJuPFCk3XigSLvxQJF244Bipt14oEi78UCRduOBIu3GA0WBogOKtBsPFGk3HijSbjxQpN14oEi7cUBRaDceKNJuPFCk3XigSLvxQFGg6IAi7cYDRdqNB4q0Gw8UaTceKNJuHFAstBsPFGk3HijSbjxQpN14oChQdECRduOBIu3GA0XajQeKtBsPFGk3J1GUkpeFkGm6f3CrC8Q2tRuGlXJjnyHdxj5Dqo19hjQb+wwFhuYZ0mvsM6TW2GdIq7HPkFJjnyGdxjzDiU5jnyGdxj5DOo19hnQa+wwFhuYZ0mnsM6TT2GdIp7HPkE5jnyGdxjzDRqexz5BOY58hncY+QzqNfYYCQ/MM6TT2GdJp7DOk09hnSKexz5BOY57hTKexz5BOY58hncY+QzqNfYYCQ/MM6TT2GdJp7DOk09hnSKexz5BOY53hNNBp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk05hnONJp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk05hnmOg09hnSaewzpNPYZ0insc9QYGieIZ3GPkM6jX2GdBr7DOk09hnSacwzzHQa+wzpNPYZ0mnsM6TT2GcoMDTPkE5jnyGdxj5DOo19hnQa+wzpNOYZCp3GPkM6jX2GdBr7DOk09hkKDM0zpNPYZ0insc+QTmOfIZ3GPkM6jXmGhU5jnyGdxj5DOo19hnQa+wwFhuYZ0mnsM6TT2GdIp7HPkE5jnyGdxjzDSqexz5BOY58hncY+QzqNfYYCQ/MM6TT2GdJp7DOk09hnSKexz5BOY57hRKexz5BOY58hncY+QzqNfYYCQ/MM6TT2GdJp7DOk09hnSKexz5BOY55ho9PYZ0insc+QTmOfIZ3GPkOBoXmGdBr7DOk09hnSaewzpNPYZ0inMc9wptPYZ0insc+QTmOfIZ3GPkOBoXmGdBr7DOk09hnSaewzpNPYZ0insc6wDXQa+wzpNPYZ0mnsM6TT2GcoMDTPkE5jnyGdxj5DOo19hnQa+wzpNOYZjnQa+wzpNPYZ0mnsM6TT2GcoMDTPkE5jnyGdxj5DOo19hnQa+wzpNOYZJjqNfYZ0GvsM6TT2GdJp7DMUGJpnSKexz5BOY58hncY+QzqNfYZ0GvMMM53GPkM6jX2GdBr7DOk09hkKDM0zpNOcxTDLyrCNt2CIL+eASXVeH3aScguGoqIUDJlEKRjah04wQtBQCoZKoRQM6UEpGHqCUjACGJ1gmPyVgmHyVwqGyV8pGCZ/pWCY/HWCKUz+SsEw+SsFw+SvFAyTv1IwAhidYJj8lYJh8lcKhslfKRgmf6VgmPx1gqlM/krBMPkrBcPkrxQMk79SMAIYnWCY/JWCYfJXCobJXykYJn+lYJj8dYKZmPyVgmHyVwqGyV8pGCZ/pWAEMDrBMPkrBcPkrxQMk79SMEz+SsEw+esE05j8lYJh8lcKhslfKRgmf6VgBDA6wTD5KwXD5K8UDJO/UjBM/krBMPnrBDMz+SsFw+SvFAyTv1IwTP5KwQhgdIJh8lcKhslfKRgmf6VgmPyVgmHyVwlmHpj8lYJh8lcKhsn/HDB5GJbnlofS7h88zmX5PrNxbvmWIpnAA0WBogOKBAgPFKkVHiiSNjxQpIN4oEg0cUBxpLB4oEiO8UCRduOBIu3GA0WBogOKtBsPFGk3HijSbjxQpN14oEi7cUAx0W48UKTdeKBIu/FAkXbjgaJA0QFF2o0HirQbDxRpNx4o0m48UKTdOKCYaTceKNJuPFCk3XigSLvxQFGg6IAi7cYDRdqNB4q0Gw8UaTceKNJuHFAU2o0HirQbDxRpNx4o0m48UBQoOqBIu/FAkXbjgSLtxgNF2o0HirQbBxQL7cYDRdqNB4q0Gw8UaTceKAoUHVCk3XigSLvxQJF244Ei7cYDRdqNA4qVduOBIu3GA0XajQeKtBsPFAWKDijSbjxQpN2cRFFKXhZCpun+wa0uENvUbhlSbuwzpNvYZ0i1Mc9wotnYZ0ixsc+QXmOfIbXGPkOBoXmGlBr7DOk09hnSaewzpNPYZ0inMc+w0WnsM6TT2GdIp7HPkE5jn6HA0DxDOo19hnQa+wzpNPYZ0mnsM6TTmGc402nsM6TT2GdIp7HPkE5jn6HA0DxDOo19hnQa+wzpNPYZ0mnsM6TTGGcow0Cnsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOe4Uinsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOeYaLT2GdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TT2GdIpzHPMNNp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk05hnKHQa+wzpNPYZ0mnsM6TT2GcoMDTPkE5jnyGdxj5DOo19hnQa+wzpNOYZFjqNfYZ0GvsM6TT2GdJp7DMUGJpnSKexz5BOY58hncY+QzqNfYZ0GvMMK53GPkM6jX2GdBr7DOk09hkKDM0zpNPYZ0insc+QTmOfIZ3GPkM6jXmGE53GPkM6jX2GdBr7DOk09hkKDM0zpNPYZ0insc+QTmOfIZ3GPkM6jXmGjU5jnyGdxj5DOo19hnQa+wwFhuYZ0mnsM6TT2GdIp7HPkE5jnyGdxjzDmU5jnyGdxj5DOo19hnQa+wwFhuYZ0mnsM6TT2GdIp7HPkE5jnyGdxjrDCyAYmmdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TT2GdIpzHPcKTT2GdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TT2GdIpzHPMNFp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk05hnmOk09hnSaewzpNPYZ0insc9QYGieIZ3GPkM6jX2GdBr7DOk09hnSacwzFDqNfYZ0GvsM6TRnMcyyMmzjLRjiyzlgUp3Xh52k3IIRwOgEQyZRCob2oRQMQUMpGCqFUjCkB51gCj1BKRgigVIwTP5KwTD5KwUjgNEJhslfKRgmf6VgmPyVgmHyVwqGyV8nmMrkrxQMk79SMEz+SsEw+SsFI4DRCYbJXykYJn+lYJj8lYJh8lcKhslfJ5iJyV8pGCZ/pWCY/JWCYfJXCkYAoxMMk79SMEz+SsEw+SsFw+SvFAyTv04wjclfKRgmf6VgmPyVgmHyVwpGAKMTDJO/UjBM/krBMPkrBcPkrxQMk79OMDOTv1IwTP5KwTD5KwXD5K8UjABGJxgmf6VgmPyVgmHyVwqGyV8pGCZ/lWDSwOSvFAyTv1IwTP5KwTD5KwUjgNEJhslfKRgmf6VgmPyVgmHyVwqGyf8cMHkYlueWh9LuH3zZBFi+z+wS0fINxZFM4IEiTcEDRQKEB4rUCg8UBYoOKNJBPFAkmnigSGHxQJEc44Ei7cYBxUS78UCRduOBIu3GA0XajQeKAkUHFGk3HijSbjxQpN14oEi78UCRduOAYqbdeKBIu/FAkXbjgSLtxgNFgaIDirQbDxRpNx4o0m48UKTdeKBIu3FAUWg3HijSbjxQpN14oEi78UBRoOiAIu3GA0XajQeKtBsPFGk3HijSbhxQLLQbDxRpNx4o0m48UKTdeKAoUHRAkXbjgSLtxgNF2o0HirQbDxRpNw4oVtqNB4q0Gw8UaTceKNJuPFAUKDqgSLvxQJF2MzqgSLvxQJF244Ei7cYBxYl244Ei7cYDRdqNB4q0m5MoSsnLQsg03T+41QVim9otQ4GheYZ0G/sMqTb2GdJs7DOk2NhnSK8xz7BRa+wzpNXYZ0ipsc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNOYZzjTaewzpNPYZ0insc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNNYZ5gHOo19hnQa+wzpNPYZ0mnsMxQYmmdIp7HPkE5jnyGdxj5DOo19hnQa8wxHOo19hnQa+wzpNPYZ0mnsMxQYmmdIp7HPkE5jnyGdxj5DOo19hnQa8wwTncY+QzqNfYZ0GvsM6TT2GQoMzTOk09hnSKexz5BOY58hncY+QzqNeYaZTmOfIZ3GPkM6jX2GdBr7DAWG5hnSaewzpNPYZ0insc+QTmOfIZ3GPEOh09hnSKexz5BOY58hncY+Q4GheYZ0GvsM6TT2GdJp7DOk09hnSKcxz7DQaewzpNPYZ0insc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNOYZ1jpNPYZ0mnsM6TT2GdIp7HPUGBoniGdxj5DOo19hnQa+wzpNPYZ0mnMM5zoNPYZ0mnsM6TT2GdIp7HPUGBoniGdxj5DOo19hnQa+wzpNPYZ0mnMM2x0GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TTmGc50GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TTWGcpAp7HPkE5jnyGdxj5DOo19hgJD8wzpNPYZ0mnsM6TT2GdIp7HPkE5jnuFIp7HPkE5jnyGdxj5DOo19hgJD8wzpNPYZ0mnsM6TT2GdIp7HPkE5jnmGi09hnSKexz5BOY58hncY+Q4GheYZ0GvsM6TT2GdJp7DOk09hnSKcxzzDTaewzpNPYZ0insc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNOYZyh0GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TRnMcyyMmzjDZhCfDkHTKrz+rCTlFswFBWlYMgkSsHQPpSCEcDoBEOlUAqG9KAUDD1BKRgigVIwTP46wVQmf6VgmPyVgmHyVwqGyV8pGAGMTjBM/krBMPkrBcPkrxQMk79SMEz+OsFMTP5KwTD5KwXD5K8UDJO/UjACGJ1gmPyVgmHyVwqGyV8pGCZ/pWCY/HWCaUz+SsEw+SsFw+SvFAyTv1IwAhidYJj8lYJh8lcKhslfKRgmf6VgmPx1gpmZ/JWCYfJXCobJXykYJn+lYAQwOsEw+SsFw+SvFAyTv1IwTP5KwTD5qwRTBiZ/pWCY/JWCYfJXCobJXykYAYxOMEz+SsEw+SsFw+SvFAyTv1IwTP46wYxM/krBMPkrBcPkrxQMk79SMAIYnWCY/JWCYfI/B0wehuW55aG0+wePc1m+z2ycW76lSCbwQJGm4IEiAcIBxUSt8ECRtOGBIh3EA0WiiQeKAkUHFMkxHijSbjxQpN14oEi78UCRduOAYqbdeKBIu/FAkXbjgSLtxgNFgaIDirQbDxRpNx4o0m48UKTdeKBIu3FAUWg3HijSbjxQpN14oEi78UBRoOiAIu3GA0XajQeKtBsPFGk3HijSbhxQLLQbDxRpNx4o0m48UKTdeKAoUHRAkXbjgSLtxgNF2o0HirQbDxRpNw4oVtqNB4q0Gw8UaTceKNJuPFAUKDqgSLvxQJF244Ei7cYDRdqNB4q0GwcUJ9qNB4q0Gw8UaTceKNJuPFAUKDqgSLvxQJF244Ei7cYDRdqNB4q0GwcUG+3mJIpS8rIQMk33D251gdimdsuQcmOfId3GPkOqjX2GAkPzDCk29hnSa+wzpNbYZ0irsc+QUmOe4Uynsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOdYR3oNPYZ0mnsM6TT2GdIp7HPUGBoniGdxj5DOo19hnQa+wzpNPYZ0mnMMxzpNPYZ0mnsM6TT2GdIp7HPUGBoniGdxj5DOo19hnQa+wzpNPYZ0mnMM0x0GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TTmGWY6jX2GdBr7DOk09hnSaewzFBiaZ0insc+QTmOfIZ3GPkM6jX2GdBrzDIVOY58hncY+QzqNfYZ0GvsMBYbmGdJp7DOk09hnSKexz5BOY58hncY8w0Knsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOeYaXT2GdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TT2GdIpzHPcKLT2GdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNPYZ0mnsM6TT2GdIpzHPsNFp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk05hnONNp7DOk09hnSKexz5BOY5+hwNA8QzqNfYZ0GvsM6TT2GdJp7DOk01hnOA10GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TTmGY50GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TTmGSY6jX2GdBr7DOk09hnSaewzFBiaZ0insc+QTmOfIZ3GPkM6jX2GdBrzDDOdxj5DOo19hnQa+wzpNPYZCgzNM6TT2GdIp7HPkE5jnyGdxj5DOo15hkKnsc+QTmOfIZ3GPkM6jX2GAkPzDOk09hnSaewzpNPYZ0insc+QTmOeYaHT2GdIp7HPkE5jnyGdxj5DgaF5hnQa+wzpNGcxzLIybOMtGOLLOWBSndeHvaToWzAUFaVgyCQ6wVTah1IwBA2lYKgUSsGQHpSCEcDoBEMkUAqGyV8pGCZ/pWCY/JWCYfLXCWZi8lcKhslfKRgmf6VgmPyVghHA6ATD5K8UDJO/UjBM/krBMPkrBcPkrxNMY/JXCobJXykYJn+lYJj8lYIRwOgEw+SvFAyTv1IwTP5KwTD5KwXD5K8TzMzkrxQMk79SMEz+SsEw+SsFI4DRCYbJXykYJn+lYJj8lYJh8lcKhslfJZg2MPkrBcPkrxQMk79SMEz+SsEIYHSCYfJXCobJXykYJn+lYJj8lYJh8tcJZmTyVwqGyV8pGCZ/pWCY/JWCEcDoBMPkrxQMk79SMEz+SsEw+SsFw+SvE0xi8lcKhslfKRgmf6VgmPzPAZOHYXlueSjt/sHjXJbvMxvnlm8pChQdUKQpeKBIgPBAkVrhgSJpwwNFOogDiplo4oEihcUDRXKMB4q0Gw8UBYoOKNJuPFCk3XigSLvxQJF244Ei7cYBRaHdeKBIu/FAkXbjgSLtxgNFgaIDirQbDxRpNx4o0m48UKTdeKBIu3FAsdBuPFCk3XigSLvxQJF244GiQNEBRdqNB4q0Gw8UaTceKNJuPFCk3TigWGk3HijSbjxQpN14oEi78UBRoOiAIu3GA0XajQeKtBsPFGk3HijSbhxQnGg3HijSbjxQpN14oEi78UBRoOiAIu3GA0XajQeKtBsPFGk3HijSbhxQbLQbDxRpNx4o0m48UKTdeKAoUHRAkXbjgSLtxgNF2s1JFKXkZSFkmu4f3OoCsU3tliHlxj5Duo15hjPVxj5Dmo19hhQb+wzpNfYZCgzNM6TV2GdIqbHPkE5jnyGdxj5DOo11hvNAp7HPkE5jnyGdxj5DOo19hgJD8wzpNPYZ0mnsM6TT2GdIp7HPkE5jnuFIp7HPkE5jnyGdxj5DOo19hgJD8wzpNPYZ0mnsM6TT2GdIp7HPkE5jnmGi09hnSKexz5BOY58hncY+Q4GheYZ0GvsM6TT2GdJp7DOk09hnSKcxzzDTaewzpNPYZ0insc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNOYZyh0GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TTmGRY6jX2GdBr7DOk09hnSaewzFBiaZ0insc+QTmOfIZ3GPkM6jX2GdBrzDCudxj5DOo19hnQa+wzpNPYZCgzNM6TT2GdIp7HPkE5jnyGdxj5DOo15hhOdxj5DOo19hnQa+wzpNPYZCgzNM6TT2GdIp7HPkE5jnyGdxj5DOo15ho1OY58hncY+QzqNfYZ0GvsMBYbmGdJp7DOk09hnSKexz5BOY58hncY8w5lOY58hncY+QzqNfYZ0GvsMBYbmGdJp7DOk09hnSKexz5BOY58hncY4wzIMdBr7DOk09hnSaewzpNPYZygwNM+QTmOfIZ3GPkM6jX2GdBr7DOk05hmOdBr7DOk09hnSaewzpNPYZygwNM+QTmOfIZ3GPkM6jX2GdBr7DOk05hkmOo19hnQa+wzpNPYZ0mnsMxQYmmdIp7HPkE5jnyGdxj5DOo19hnQa8wwzncY+QzqNfYZ0GvsM6TT2GQoMzTOk09hnSKexz5BOY58hncY+QzqNeYZCp7HPkE5jnyGdxj5DOo19hgJD8wzpNPYZ0mnsM6TT2GdIp7HPkE5jnmGh09hnSKexz5BOY58hncY+Q4GheYZ0GvsM6TT2GdJp7DOk09hnSKcxz7DSaewzpNPYZ0insc+QTnMWwywrwzbeghHAnAIm1Xl92EnKLRiKilIwZBKlYGgfSsEQNJSCoVLoBDORHpSCoScoBUMkUAqGyV8pGAGMTjBM/krBMPkrBcPkrxQMk79SMEz+OsE0Jn+lYJj8lYJh8lcKhslfKRgBjE4wTP5KwTD5KwXD5K8UDJO/UjBM/jrBzEz+SsEw+SsFw+SvFAyTv1IwAhidYJj8lYJh8lcKhslfKRgmf6VgmPxVgrmsOmB0gmHyVwqGyV8pGCZ/pWAEMDrBMPkrBcPkrxQMk79SMEz+SsEw+esEMzL5KwXD5K8UDJO/UjBM/krBCGB0gmHyVwqGyV8pGCZ/pWCY/JWCYfLXCSYx+SsFw+SvFAyTv1IwTP5KwQhgdIJh8lcKhslfKRgmf6VgmPyVgmHy1wkmM/mfAyYPw/Lc8lDa/YPHuSzfZzbOLd9SJBN4oEhT8ECRAOGBokDRAUXShgeKdBAPFIkmHihSWDxQJMc4oCi0Gw8UaTceKNJuPFCk3XigKFB0QJF244Ei7cYDRdqNB4q0Gw8UaTcOKBbajQeKtBsPFGk3HijSbjxQFCg6oEi78UCRduOBIu3GA0XajQeKtBsHFCvtxgNF2o0HirQbDxRpNx4oChQdUKTdeKBIu/FAkXbjgSLtxgNF2o0DihPtxgNF2o0HirQbDxRpNx4oChQdUKTdeKBIu/FAkXbjgSLtxgNF2o0Dio1244Ei7cYDRdqNB4q0Gw8UBYoOKNJuPFCk3XigSLvxQJF244Ei7cYBxZl244Ei7cYDRdqNB4q0Gw8UBYrnUJSSl4WQabp/cKsLxDa1W4aUG/sM6Tb2GVJt7DOk2dhnSLGxzjAN9Br7DKk19hnSauwzpNTYZygwNM+QTmOfIZ3GPkM6jX2GdBr7DOk05hmOdBr7DOk09hnSaewzpNPYZygwNM+QTmOfIZ3GPkM6jX2GdBr7DOk05hkmOo19hnQa+wzpNPYZ0mnsMxQYmmdIp7HPkE5jnyGdxj5DOo19hnQa8wwzncY+QzqNfYZ0GvsM6TT2GQoMzTOk09hnSKexz5BOY58hncY+QzqNeYZCp7HPkE5jnyGdxj5DOo19hgJD8wzpNPYZ0mnsM6TT2GdIp7HPkE5jnmGh09hnSKexz5BOY58hncY+Q4GheYZ0GvsM6TT2GdJp7DOk09hnSKcxz7DSaewzpNPYZ0insc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNOYZzjRaewzpNPYZ0insc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNOYZ9joNPYZ0mnsM6TT2GdIp7HPUGBoniGdxj5DOo19hnQa+wzpNPYZ0mnMM5zpNPYZ0mnsM6TT2GdIp7HPUGBoniGdxj5DOo19hnQa+wzpNPYZ0mmsM8wDncY+QzqNfYZ0GvsM6TT2GQoMzTOk09hnSKexz5BOY58hncY+QzqNeYYjncY+QzqNfYZ0GvsM6TT2GQoMzTOk09hnSKexz5BOY58hncY+QzqNeYaJTmOfIZ3GPkM6jX2GdBr7DAWG5hnSaewzpNPYZ0insc+QTmOfIZ3GPMNMp7HPkE5jnyGdxj5DOo19hgJD8wzpNPYZ0mnsM6TT2GdIp7HPkE5jnqHQaewzpNPYZ0insc+QTmOfocDQPEM6jX2GdBr7DOk09hnSaewzpNOYZ1joNPYZ0mnsM6TT2GdIp7HPUGBoniGdxj5DOo19hnQa+wzpNPYZ0mnMM6x0GvsM6TT2GdJp7DOk09hnKDA0z5BOY58hncY+QzqNfYZ0GvsM6TTmGU50mrMYZlkZtvEWDPHlJDBN1h+u9vPjfoChqCgFQyZRCkYAoxMMQUMpGCqFUjCkB6Vg6AlKwRAJdIJpTP5KwTD5KwXD5K8UDJO/UjACGJ1gmPyVgmHyVwqGyV8pGCZ/pWCY/HWCmZn8lYJh8lcKhslfKRgmf6VgBDA6wTD5KwXD5K8UDJO/UjBM/krBMPmrBCMDk79SMEz+SsEw+SsFw+SvFIwARicYJn+lYJj8lYJh8lcKhslfKRgmf51gRiZ/pWCY/JWCYfJXCobJXykYAYxOMEz+SsEw+SsFw+SvFAyTv1IwTP46wSQmf6VgmPyVgmHyVwqGyV8pGAGMTjBM/krBMPkrBcPkrxQMk79SMEz+OsFkJn+lYJj8lYJh8lcKhslfKRgBjE4wTP5KwTD5KwXD5H8OGBnqcgkypnr/4HEuy/eZjXPboEgmOIdiGeYFTBnzcAuGTKATjJAJlIIhEygFQyZQCoZMoBSMAEYnGDKBUjBkAqVgyARKwTD5KwXD5K8TTGHyVwqGyV8pGCZ/pWCY/JWCEcDoBMPkrxQMk79SMEz+SsEw+SsFw+SvE0xl8lcKhslfKRgmf6VgmPyVghHA6ATD5K8UDJO/UjBM/krBMPkrBcPkrxPMxOSvFAyTv1IwTP5KwTD5KwUjgNEJhslfKRgmf6VgmPyVgmHyVwqGyV8nmMbkrxQMk79SMEz+SsEw+SsFI4DRCYbJXykYJn+lYJj8lYJh8lcKhslfJ5iZyV8pGCZ/pWCY/JWCYfJXCkYAoxMMk79SMEz+SsEw+SsFw+SvFAyTv0owZWDyVwqGyV8pGCZ/pWCY/E8Ck9evZyqXBbwFI4DRCYbJXykYJn+lYJj8lYJh8lcKhslfJ5iRyV8pGCZ/pWCY/JWCYfJXCkYAoxMMk79SMEz+SsEw+SsFw+SvFAyTv04wiclfKRgmf6VgmPyVgmHyVwpGAKMTDJO/UjBM/krBMPkrBcPkrxQMk79OMJnJXykYJn+lYJj8lYJh8lcKRgCjEwyTv1IwTP5KwTD5KwXD5K8UDJO/TjDC5K8UDJO/UjBM/krBMPkrBSOA0QmGyV8pGCZ/pWCY/JWCYfJXCobJXyeYwuSvFAyTv1IwTP5KwTD5KwUjgNEJhslfKRgmf6VgmPyVgmHyVwqGyV8nmMrkrxQMk79SMEz+SsEw+SsFI4DRCYbJXykYJn+lYJj8zwFTh7xcbh3mdAuGyV8pGCZ/nWAmJn+lYJj8lYJh8lcKhslfKRgBjE4wTP5KwTD5KwXD5H8SmDwsq1ZzzrdgmPyVgmHy1wmmMfkrBcPkrxQMk79SMEz+SsEIYHSCYfJXCobJXykYJn+lYJj8lYJh8tcJZmbyVwqGyV8pGCZ/pWCY/JWCEcDoBMPkrxQMk79SMEz+SsEw+SsFw+SvEkwdmPyVgmHyVwqGyV8pGCZ/pWAEMDrBMPkrBcPkrxQMk79SMEz+SsEw+esEMzL5KwXD5K8UDJO/UjBM/krBCGB0gmHyVwqGyV8pGCZ/pWCY/JWCYfLXCSYx+SsFw+SvFAyTv1IwTP5KwQhgdIJh8lcKhslfKRgmf6VgmPyVgmHy1wkmM/krBcPkrxQMk79SMEz+J4GpVRYwdS63YAQwOsEw+SsFw+R/EphpWC6hTnm+f3BLZaHY0tWybR9c03Lsz4d+AKcoBANOqQgGnAISC7hQVoIBp9gEA04JCgacwhQMuAA8FnCKWDDglLZgwCltwYBT2oIBp7TFAl4obcGAU9qCAae0BQNOaQsGXAAeCzilLRhwSlsw4JS2YMApbcGAU9piAa+UtmDAKW3BgFPaggGntAUDLgCPBZzSFgw4pS0YcEqbCeC5rMBbvaVIPrNAMU/LwU1GuX9wHqa8LPHQ5qtnt7XEY1menYxTvj74ww9qG37c8WMizuHHPT9oefhxzw/SH37c84NSiB/3/BD8wI87ftAh8eOeH2RL/LjnB5UTP+75QT/Fj3t+0E/x444fjX6KH/f8oJ/ixz0/6Kf4cc8P+il+3PND8AM/7vhBP8WPe37QT/Hjnh/0U/y45wf9FD/u+UE/xY87fsz0U/y45wf9FD/u+UE/xY97ftBP8eOeH4If+HHHD/opftzzg36KH/f8oJ/ixz0/6Kf4cc8P+il+7PsxDfRT/LjnB/0UP+75QT/Fj3t+0E/x454fgh/4cccP+il+3PODfoof9/ygn+LHPT/op/hxzw/6KX7c8WOkn+LHPT/op/hxzw/6KX7c84N+ih/3/BD8wI87ftBP8eOeH/RT/LjnB/0UP+75QT/Fj3t+0E/x444fiX6KH/f8oJ/ixz0/6Kf4cc8P+il+3PNDFPtRhis/rr68d9uPdPlluFxHul7yad6ini5Ls3BPInJ9+MfSaE6HJy+N5mr25NLMZflpGvMw/LQ0v1/+49//6y9//etf/vf/+Ovf/+PP//jL3//2399OHr79P9tfndSG9fumx3b14/b9523723Tun9KeP2V++pTtr2G4f8r4/Cnp+VPy86fI86eU5095nn57nn57nn57nv78PP35efrbHzU1teXHr6Xx5pT8/Cny/Cnl+VPq86dMT55y+a/x25HbI6Dk5ZectM9bkVHSt39reyq4f0p+/hR5/pTy/Cn1+VOm509pz58yP31K3vxBK+tfoFJvTxmfPyU9f0p+/pRN+mX9Q12menNKef6U+vwp0/OnbNIv84KyXt3NLKfMT58iw/OnjM+fkh6d0m5Oyc+fIs+fskm/luU2sNZyc0p9/pTp+VPa86ds0r/MfOvIN/96ShmeP2V8/pT0/Cmb9OssP06Zhnxzijx/Snn+lPr8KdODU8bx5pT2/Cnz06fUTfrTmimmevPzUsfnT0nPn5KfP2X7FmutEtPtH75anj+lPn/K9Pwpm/Sneflj0YabPxZ1fvqUaXj+lPH5U9KDU67K0nJKfv4Uef6U7fGqLr+UWr35pbQzXN89ZXr+lPb8Kdvj1bT87Ld28/R3huu7p4zPn5KeP2V7uJ7XdjrcPP2d4fruKeX5U+rzp0wPThmnm1Pa86fMT5+yPVzP69w3zzd/xbaH6/unpOdPyU+ecvmv9O3IzWW7jKxLMvzpFuOjouVvR26/V2ha8/t0HbPLZsxe+uJlyrp/aMdIvv0WFv2XnWxedrZ52WLzsovNy642L3uyedntXZf97cHnNz54Gt754C//XVj3qeQqr/148PTOB8/vfHB554O//PtqfRGBzDdA6zsffHrng7/6E1rWDd8y1l8ffH7jg+fhnQ8+vvPBX1Wx5GU0K/nmwes7H/xVoFWmNY0Ovzy4DO98cHnjssjLQNc/ouWqGP948PrOB5/e+eDtnQ8+v/HBy/DOBx/f+eCp34NP8uuD53c++Ms/oWX9CW03D/7yT+j6u2Xjwes7H3x654O/+hNax3Xb7qpf/Xjw+Y0PXod3Pvj4zgd/9Se0Dnl98Pbrg+d3Pri888HLOx+8vvPBp3c+eHvng8/9Hjz96vk0vPPBX/4JHZaXtdZ88+Av/w1d93M3Hjy/88HlnQ/+8k/onfvzqb7zwad3Pnh754O/c+Bq7xy42vjOB09ve/DLf8i3A3dePjatf9h/el1bvfPysf1TLv9Vvh25vXNR27IvNsn1ftq4lXg+b6x/egXJuL/D0O/hy3sfvr734af3Pnx778PPb3347Qre7+HH9z58evXhy7jOTqU9OHYc8voelkGu/njmtl/Oz7oY0XQxRdPF1K+9mLK+u2qo483FTJoupmm6mFnRxeThay9mWt/+NrRyczGjpotJmi4ma7oYOe1irl6ctVxM0XQxVdPFfO1v4HF9F9w4Xr0YdrmYpuliZkUXI4Oai7n8V/0+021/PM/l0ZdTy9TuD6mtLZNjm+X+oW9/0aKFC09WLzxbvXCxeuHF6oVXqxc+Wb3w9r4L/30v4HR7+DS89+Ff/1sxp+WP9JznL6OaktULz1YvXKxeeLF64dXqhU9WL7y978J/34te3R4+D+99+PG9D5/e+/D5vQ8v73348t6Hr+99+OmtDy+vizkOo6wVKeVf/4H07n/gdbxjKksA+faZb7/+A+3dz2B+8z9QejBow2cqvHm1Y373PyDv/gfKu/+B+u5/YOrwD0yfWz3zry+YK+3d/8D85n+gDu/+B8Z3/wPp3f9Afvc/0OEn+fL7ek3Q5dc3ddXy7n+gvvsfmN79D7R3/wPzm/+BaXj3P9DhJ3lcPxNiHOdfb7ym9O5/4N33RVN99z8wvfsfaG/+B9rw7n9gfPc/kN79D+R3/wPy1n/g8h/Tt0N3tjyrrL9kaq0P/hkZPz/bOf36PHb2m577B9bPJxulPThY1eaUt2dZQzzLKcSzbCGe5RzhWaYhxLMcQzzLpORZ/r67cXnOtYiia/niv/aq9iK9PcspxLNsIZ7lHOFZ5iHEsxxDPMuk5Fn+vrtdfs61iKJr0fLX/vfdXftzrkXLX87f995mcdK1aPkr9PvemyxOuhYtv9F/3331xduu5cErKaqqq/lif+938JI0rU3Jqq7my7058EqOs66mqbqaWdPV1EHV1YxffTUHXqpy1tVkVVcjqq6mqLqaqupqJlVX89W/i4+8yuekq5kGVVczqrqapOpqsqqrEVVX89W/i++/hqyquhpV81QbVF3NqOpqsqqrEVVXU1RdTVV1NZOeq7n8R/t26M5v5KGuv6mG+rmvne/93rx/znTgnHbgnPn5c3Z+190/ZzxwTjpwTj5wjhw454AH7YAH7YAH7YAH7YAH8wEP5gMezAc8mA94MB/wYD7gwbztwbh+Uv7lf6Vfz5kOnNMOnDM/f844bIswrl8Be7mTuz1pPHJSOnJSPnKSHDmpHDmpHjlpOnLSjhDrF86Pabg9aT5w0s4HUKW0/likJDcnbS95Wr9Dfkw135w0HThp55Wd+fMD8PJ885x2Xij54KRtI9L0eadx9YmIy0n10Ul5GG5Omg+ctPOilwcn7SyErEbkq0+TXU5KR07KR06SIyeVIyfVIydNR05qR07aNiKv38d2Wd/260k7W9sPThqPnJSOnJSPnCRHTipHTqpHTpqOnNSOnHTEiHLEiHLEiJ1N6fu/YXf2jh+cJEdOKkdOqkdOmo6cNB84qR75S1iP/CWsR+DWp+Fe/mP+dujODZzk9ZsxJLeb97Vs38A9OqkeOWk6clI7ctJ84KTtNzA+Omk8clI6ctL2VwcNaak903D793Dn68UfnFSOnLT9RTiXm6nlpHHjpPnASTvf5TtOZT1pmv7Y/eWDk3a+ZDa1dSHyUP/YreKjk9KRk/KRk+TISe3I6u3Andd/KY3TH7sXe3TSeOQkOXJSOXLStnuprh9Qner0x+6QpiTD50n5j90hPTppPnDSznekPjhpPHJSOnJSPnKSHDmpHDmpHjnpiBHliBHliBH1iBH1yC/LeuSXZT3yy7Ie+WW5812WD06qR05qR06aD5w0HflLOB2BOz0N919/+v7ZE//cvZW9/77unVvZBydNR05qR06aD5y0cyv74KTxyEnpyEn5yEnbP4tlfTHJVGT8g7eyD06qR06ajpzUjpw0HzhpO/8+Omk8clI6ctL2b+eyvj1uKhvNeMeI9QWEU5l/Ci4bb8CbZfm9kufrr1PffAPe/QFtZy457XKqrsuZdF1O03U5s6rL2Rl8T7ucUdflJF2Xk3Vdjq7fylnXb+X87G/l33f3zx6d1A6cJDtfrTyud9813fzxlnzkpO2FmOflL34bxptt2J0o8uCkduSk+cBJ5cjq7aSKKa/3S5d7p3/9sVTx4KTthWjrKxSmdvX21vstoK0vMpzadDtjDkdO2jFiWC9vHuQPTrPz53Oay/AHp9n7cHem2QcnpSMn5SMnyZGTjiz5NB05aeeHMH+eJDfuTfOBk3a+1/7BSeORk9KRk3bgls+T6s2k0+TISeXISfXISdORk9qRk+YDJ83DkZPGA79Y5nTkpHzkJDlyUjlyUj1y0nTkpHbkpAN/ANIwHDlpPHJSOnJSPnKSHDmpHDmpHjlpfv6OJW13zEcnbXOa1r+El/8pNydtc5rq9HnSzXPa2ZJ/cJIcOakcOakeOWk6clI7ctJ84KSdjvngpPHISUeMSEeMSEeMSEeM2GmCdyeAtFPuHpzUjpw0Hzhpp1U9OOnAfXnK+chJcuSkcuSkpyfqf/3p+/c9//O3Ug68p6OUeuSk6chJ7chJB97fU+pw5KTxyEnpyEn5yEly5KQjRtQjRtQjRtQjRtQjRkxHjJiOGDEdMWI6YsR0xIgj7wMt04E3fpVpOnJSO3LSgfd+lXbgvV+ljUdOSkdOykdOkiMnlSMn1SMnTUdOOvDer9IOvPerzAfe+1V23nt5921cZT7w3q86HHjFex3GIycdeO9XHQ6896sOB977VcfhyEkH3vtVx3TkpHzkJDlyUjlyUj1y0nTkpHbkpAPv9KlpOHLSeOSkdOSkfOQkOXJSOXJSPXLSdOSkduSkI0bkI0bkI0bkA28PqjkfOUmOnFSOnFSPnDQdOenAe7+qHPlLKEf+EsoRuHLkvV/f/tRcRvjtvfG83rfI1R7HZcv++93E9tb4nXP+dfnP//fP//WXP//7X//zvy+nfPu//t+//cc//vL3v/34z3/8f//n4/9yOfj/Bw==","brillig_names":["debug_log_format","get_public_keys_and_partial_address","unsafe_rand","decompose_hint","notify_created_note","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","build_msg_block_iter","emit_encrypted_note_log","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"counters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Counter::increment_parameters"}}],"kind":"struct","path":"Counter::increment_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Counter::initialize_parameters"}}],"kind":"struct","path":"Counter::initialize_abi"}]}},"file_map":{"101":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"103":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"106":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"107":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"118":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n"},"120":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"121":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"128":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"133":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"134":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"141":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"142":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"143":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"146":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"149":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"151":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"156":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"183":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"238":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"247":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"250":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"252":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"256":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"266":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"267":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"283":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"29":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"290":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"301":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"326":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"330":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr","source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n    keys::getters::get_public_keys\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\npub struct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_public_keys(owner);\n        let outgoing_viewer_keys = get_public_keys(outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_keys.npk_m.hash());\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_public_keys(owner);\n        let outgoing_viewer_keys = get_public_keys(outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_keys.npk_m.hash());\n        self.set.insert(&mut result_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n    }\n}\n"},"332":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/value-note/src/balance_utils.nr","source":"use dep::aztec::{context::UnconstrainedContext, state_vars::PrivateSet, note::{note_viewer_options::NoteViewerOptions}};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(\n    set: PrivateSet<ValueNote, UnconstrainedContext>,\n    offset: u32\n) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n"},"336":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    crate::sha256::digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u64, msg_start: u32) -> ([u8; 64], u64) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            msg_block[msg_byte_ptr] = msg[k];\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u64,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u64 {\n    let mut msg_byte_ptr: u64 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    let mut extra_bytes = 0;\n    if msg_end > N {\n        msg_end = N;\n        extra_bytes = msg_end - N;\n    }\n\n    for k in msg_start..msg_end {\n        if k as u64 < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if msg_byte_ptr == 64 {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start as u64 < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start as u64 < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start as u64 < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE as u64 {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64) -> ([u8; 64], u64) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        if msg_byte_ptr < 64 {\n            for _ in 57..64 {\n                if msg_byte_ptr <= 63 {\n                    msg_block[msg_byte_ptr] = 0;\n                    msg_byte_ptr += 1;\n                }\n            }\n        }\n    }\n    (msg_block, msg_byte_ptr)\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; 64], mut msg_byte_ptr: u64, message_size: u64) -> [u8; 64] {\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for _i in 0..64 {\n        // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n        if msg_byte_ptr < 56 {\n            msg_block[msg_byte_ptr] = 0;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        } else if msg_byte_ptr < 64 {\n            for j in 0..8 {\n                msg_block[msg_byte_ptr + j] = len_bytes[j];\n            }\n            msg_byte_ptr += 8;\n        }\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; 64], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n"},"351":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app, macros::notes::partial_note\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness: unsafe_rand(), header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"352":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"70":{"path":"/mnt/user-data/jan/aztec-artifact-bug/counter-with-token-dependency/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Counter {\n\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n    use aztec::macros::{storage::storage, functions::{initializer, private}};\n\n    //this seems to act like a map in solidity\n    #[storage]\n    struct Storage<Context> {\n        counters: Map<AztecAddress, EasyPrivateUint<Context>, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n\n    #[private]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        dep::aztec::oracle::debug_log::debug_log_format(\"Incrementing counter for owner {0}\", [owner.to_field()]);\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n        //get_balance operates on the owners counter, is this the owner of the contract or who is calling the function?\n        //yiedls a provate counter that only the owner can decrpyt. \n    }\n}\n\n//checking my understanding\n//the owner of the contract is the person who deployed it with the initaliser\n//      they can give themselves a headstart which is just more tokens on deployment\n//      i still dont understand the difference between owner and outgoing_viewer\n//      because it is private it is just someone who can view the counter, it cannot be anyone\n//      the why are they not present in the get_counter"},"79":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"81":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"84":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::{get_public_keys, get_ovsk_app}, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note,\n        num_public_values\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> (u32, [u8; M], Field) where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient, num_public_values)\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, iv, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(AztecAddress, AztecAddress, &mut PrivateContext)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Note: We could save a lot of gates by obtaining the following keys in an unconstrained context but this\n        // function is currently not used anywhere so we are not optimizing it.\n        let ovpk = get_public_keys(ov).ovpk_m;\n        let ivpk = get_public_keys(iv).ivpk_m;\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        // See the comment in `encode_and_encrypt_note_with_keys_unconstrained` for why having note hash counter\n        // and log hash unconstrained here is fine.\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, iv, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        // Number of public values is always 0 here because `encode_and_encrypt_note_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient, num_public_values);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        // Number of public values is always 0 here because `encode_and_encrypt_note_with_keys_unconstrained(...)` is only called\n        // in the non-partial note flow.\n        let num_public_values = 0;\n\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient, num_public_values)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n"},"85":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"86":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\npub struct EncryptedLogIncomingBody<let N: u32> {\n    plaintext: [u8; N * 32 + 64]\n}\n\nimpl<let N: u32> EncryptedLogIncomingBody<N> {\n    pub fn from_note<T>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T>(event: T, randomness: Field) -> Self where T: EventInterface<N> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: u32 = 3;\n\n    impl NullifiableNote for AddressNote {\n        fn compute_nullifier(\n            _self: Self,\n            _context: &mut PrivateContext,\n            _note_hash_for_nullify: Field\n        ) -> Field {\n            1\n        }\n\n        unconstrained fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n    }\n\n    struct AddressNoteHidingPoint {\n        inner: Point\n    }\n\n    impl NoteInterface<ADDRESS_NOTE_LEN> for AddressNote {\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader {\n            self.header\n        }\n\n        fn set_header(&mut self, header: NoteHeader) {\n            self.header = header;\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] {\n            [self.address.to_field(), self.owner.to_field(), self.randomness]\n        }\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote {\n                address: AztecAddress::from_field(fields[0]),\n                owner: AztecAddress::from_field(fields[1]),\n                randomness: fields[2],\n                header: NoteHeader::empty()\n            }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_LEN * 32 + 64] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_LEN * 32 + 64] = [0; ADDRESS_NOTE_LEN * 32 + 64];\n\n            let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n            let note_type_id_bytes: [u8; 32] = AddressNote::get_note_type_id().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n\n        fn compute_note_hash(_self: Self) -> Field {\n            crate::generators::Ga1.x\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        // 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        // the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        // implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        // 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: u32 = 3;\n\n    impl EventInterface<TEST_EVENT_LEN> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            comptime\n            {\n                EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n            }\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_LEN * 32 + 64] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 64] = [0; TEST_EVENT_LEN * 32 + 64];\n\n            let randomness_bytes: [u8; 32] = randomness.to_be_bytes();\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_LEN * 32 + 32] {\n            let mut buffer: [u8; TEST_EVENT_LEN * 32 + 32] = [0; TEST_EVENT_LEN * 32 + 32];\n\n            let event_type_id_bytes: [u8; 32] = TestEvent::get_event_type_id().to_field().to_be_bytes();\n\n            for i in 0..32 {\n                buffer[i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes: [u8; 32] = serialized_event[i].to_be_bytes();\n                for j in 0..32 {\n                    buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 201, 247, 40, 80, 60, 188, 158, 251, 242, 103, 197, 79, 165, 195, 10, 160, 255, 35, 167, 152, 25, 233, 77, 145, 214, 243, 210, 119, 0, 20, 29, 95, 15, 63, 33, 190, 184, 67, 254, 96, 128, 243, 220, 228, 201, 130, 86, 163, 52, 127, 111, 10, 212, 7, 160, 16, 87, 13, 39, 11, 5, 1, 164, 65, 8, 56, 82, 245, 13, 68, 176, 90, 100, 69, 243, 78, 117, 188, 221, 34, 178, 31, 155, 89, 143, 176, 129, 118, 36, 236, 64, 179, 52, 239, 184, 51, 51, 199, 221, 49, 81, 197, 17, 199, 192, 99, 49, 168, 157, 164, 190, 33, 240, 182, 214, 173, 7, 156, 102, 95, 65, 217, 225, 123, 42, 21, 124, 144\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"},"88":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\npub struct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high: [u8; 32] = self.eph_sk.hi.to_be_bytes();\n        let serialized_eph_sk_low: [u8; 32] = self.eph_sk.lo.to_be_bytes();\n\n        let address_bytes: [u8; 32] = self.recipient.to_field().to_be_bytes();\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{address::AztecAddress, scalar::Scalar};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    #[test]\n    unconstrained fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"89":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let N: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note,\n    num_public_values: u8 // Number of values to be appended to the log in public (used in partial note flow).\n) -> [u8; M] where Note: NoteInterface<N> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    encrypted_bytes[64] = num_public_values; // TODO(#8558): This can be just a single bit if we store info about partial fields in ABI\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[65 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[97 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[145 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[193 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 337;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[337 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // num_public_values (1 byte)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 0;\n\n        let log: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        assert_eq(encrypted_note_log_from_typescript, log);\n    }\n\n    #[test]\n    unconstrained fn test_encrypted_note_log_of_finalized_partial_note_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note_public_value1 = 0x14172339287e8d281545c177313f02b6aa2fedfd628cfd8b7f11a136fd0d6557;\n        let note_public_value2 = 0x0834d81e3f73c7e2809b08ae38600ffc76a2554473eeab6de7bff4b33a84feac;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n        let num_public_values: u8 = 2;\n\n        // First we compute the encrypted log without the public values\n        let log_without_public_values: [u8; 449] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note,\n            num_public_values\n        );\n\n        // Then we \"append\" the public values to the log by copying both the original log and the current log into a new byte array\n        let mut log: [u8; 513] = [0; 513];\n        for i in 0..449 {\n            log[i] = log_without_public_values[i];\n        }\n        let note_public_value1_bytes: [u8; 32] = note_public_value1.to_be_bytes();\n        let note_public_value2_bytes: [u8; 32] = note_public_value2.to_be_bytes();\n        for i in 0..32 {\n            log[449 + i] = note_public_value1_bytes[i];\n            log[481 + i] = note_public_value2_bytes[i];\n        }\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_of_finalized_partial_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38, 20, 23, 35, 57, 40, 126, 141, 40, 21, 69, 193, 119, 49, 63, 2, 182, 170, 47, 237, 253, 98, 140, 253, 139, 127, 17, 161, 54, 253, 13, 101, 87, 8, 52, 216, 30, 63, 115, 199, 226, 128, 155, 8, 174, 56, 96, 15, 252, 118, 162, 85, 68, 115, 238, 171, 109, 231, 191, 244, 179, 58, 132, 254, 172\n        ];\n        assert_eq(encrypted_note_log_of_finalized_partial_from_typescript, log);\n    }\n}\n"},"93":{"path":"/mnt/user-data/jan/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.56.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::oracle::logs_traits::ToBytesForUnencryptedLog;\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (n as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"}}}